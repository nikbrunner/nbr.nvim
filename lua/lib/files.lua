local M = {}
local ShaDa = require("shada")

---Finds a pattern in a line of a file and replaces it with a value
---@param filepath string
---@param pattern string
---@param value string
function M.update_line_in_file(filepath, pattern, value)
    -- First check if file exists and is readable
    if not vim.loop.fs_stat(filepath) then
        vim.notify("File does not exist: " .. filepath, vim.log.levels.ERROR)
        return
    end

    -- Read file safely with pcall
    local ok, lines = pcall(vim.fn.readfile, filepath)
    if not ok or not lines then
        vim.notify("Failed to read file: " .. filepath, vim.log.levels.ERROR)
        return
    end

    -- Process lines
    lines = vim.tbl_map(function(line)
        if vim.fn.match(line, pattern) ~= -1 then
            line = vim.fn.substitute(line, '".*"', value, "")
        end
        return line
    end, lines)

    -- Use a delay and write file safely with pcall
    vim.defer_fn(function()
        local write_ok, err = pcall(vim.fn.writefile, lines, filepath)
        if not write_ok then
            vim.notify("Failed to write file: " .. filepath .. " - " .. (err or "unknown error"), vim.log.levels.ERROR)
        end
    end, 500)
end

---Syncs the wezterm colorscheme with the current nvim colorscheme (if configured)
---@param config VinConfig
---@param colorscheme string
function M.sync_wezterm_colorscheme(config, colorscheme)
    local colorscheme_config = config.colorscheme_config_map[colorscheme]

    if not colorscheme_config or not colorscheme_config.wezterm then
        vim.notify("Colorscheme not configured for wezterm")
        return
    end

    -- Use absolute path to avoid issues with empty $XDG_CONFIG_HOME
    local wezterm_schemes_file = vim.fn.expand("~/.config/wezterm/.current_schemes.lua")

    -- Determine current background mode
    local current_background = vim.o.background

    -- Get current light and dark colorschemes from config
    local light_colorscheme = config.colorscheme_light
    local dark_colorscheme = config.colorscheme_dark

    local fallback_light_colorscheme_wezterm = "Black Atom — JPN ∷ Koyo Hiru"
    local fallback_dark_colorscheme_wezterm = "Black Atom — JPN ∷ Koyo Yoru"

    -- Get wezterm mappings for both
    local light_wezterm = config.colorscheme_config_map[light_colorscheme]
            and config.colorscheme_config_map[light_colorscheme].wezterm
        or fallback_light_colorscheme_wezterm
    local dark_wezterm = config.colorscheme_config_map[dark_colorscheme]
            and config.colorscheme_config_map[dark_colorscheme].wezterm
        or fallback_dark_colorscheme_wezterm

    -- If we're manually changing to a specific colorscheme, update the appropriate mode
    if current_background == "light" then
        light_wezterm = colorscheme_config.wezterm
    else
        dark_wezterm = colorscheme_config.wezterm
    end

    -- Ensure the parent directory exists
    local parent_dir = vim.fn.fnamemodify(wezterm_schemes_file, ":h")
    if vim.fn.isdirectory(parent_dir) == 0 then
        vim.notify("WezTerm config directory not found: " .. parent_dir, vim.log.levels.WARN)
        return
    end

    local content = string.format(
        [[-- This file is automatically generated by Neovim
-- Contains current colorscheme mappings for light and dark modes
return {
    light = "%s",
    dark = "%s"
}]],
        light_wezterm,
        dark_wezterm
    )

    -- Write the file safely with pcall
    local write_ok, err = pcall(vim.fn.writefile, vim.split(content, "\n"), wezterm_schemes_file)
    if not write_ok then
        vim.notify_once("Failed to write wezterm schemes file: " .. (err or "unknown error"), vim.log.levels.ERROR)
    end
end

---Syncs the ghostty colorscheme with the current nvim colorscheme (if configured)
---@param config VinConfig
---@param colorscheme string
function M.sync_ghostty_colorscheme(config, colorscheme)
    local colorscheme_config = config.colorscheme_config_map[colorscheme]

    if not colorscheme_config or not colorscheme_config.ghostty then
        -- Silently skip if colorscheme doesn't have ghostty config
        return
    end

    -- Ensure ghostty config is a string (theme filename)
    if type(colorscheme_config.ghostty) ~= "string" then
        vim.notify("Ghostty config must be a theme filename string, not a table", vim.log.levels.ERROR)
        return
    end

    -- Use absolute path to Ghostty config
    local ghostty_config_file = vim.fn.expand("~/.config/ghostty/config")
    local ghostty_config_dir = vim.fn.fnamemodify(ghostty_config_file, ":h")

    -- Ensure the parent directory exists
    if vim.fn.isdirectory(ghostty_config_dir) == 0 then
        local mkdir_ok = pcall(vim.fn.mkdir, ghostty_config_dir, "p")
        if not mkdir_ok then
            vim.notify("Failed to create ghostty config directory: " .. ghostty_config_dir, vim.log.levels.ERROR)
            return
        end
    end

    -- Get the actual saved colorschemes from state (source of truth)
    local light_colorscheme = ShaDa.read("colorscheme_light")
    local dark_colorscheme = ShaDa.read("colorscheme_dark")
    local current_background = vim.o.background

    -- Get ghostty theme names for both modes from the saved state colorschemes
    local light_config = config.colorscheme_config_map[light_colorscheme]
    local light_theme = (light_config and type(light_config.ghostty) == "string") and light_config.ghostty
        or "black-atom-jpn-koyo-hiru.conf"

    local dark_config = config.colorscheme_config_map[dark_colorscheme]
    local dark_theme = (dark_config and type(dark_config.ghostty) == "string") and dark_config.ghostty
        or "black-atom-jpn-koyo-yoru.conf"

    -- If we're manually changing to a specific colorscheme, update the appropriate mode
    -- and also update the state to remember this choice
    if current_background == "light" then
        light_theme = colorscheme_config.ghostty
        ShaDa.update("colorscheme_light", colorscheme)
    else
        dark_theme = colorscheme_config.ghostty
        ShaDa.update("colorscheme_dark", colorscheme)
    end

    -- Build the theme line
    local theme_line = string.format("theme = dark:%s,light:%s", dark_theme, light_theme)

    -- Read existing config if it exists, or create empty
    local lines = {}
    if vim.loop.fs_stat(ghostty_config_file) then
        local read_ok, file_lines = pcall(vim.fn.readfile, ghostty_config_file)
        if read_ok and file_lines then
            lines = file_lines
        end
    end

    -- Update or add theme line
    local theme_updated = false
    for i, line in ipairs(lines) do
        if line:match("^theme%s*=") then
            lines[i] = theme_line
            theme_updated = true
            break
        end
    end

    -- If no theme line found, add it
    if not theme_updated then
        table.insert(lines, theme_line)
    end

    -- Write the file safely with pcall
    local write_ok, err = pcall(vim.fn.writefile, lines, ghostty_config_file)
    if not write_ok then
        vim.notify_once("Failed to write ghostty config file: " .. (err or "unknown error"), vim.log.levels.ERROR)
    end
end

---Detects printwidth from .prettierrc or .editorconfig files
---@param start_path? string The directory to start searching from (defaults to current buffer directory)
---@return number|nil printwidth The detected printwidth or nil if not found
function M.detect_printwidth(start_path)
    start_path = start_path or vim.fn.expand("%:p:h")

    local function find_config_file(dir, filename)
        local filepath = dir .. "/" .. filename
        if vim.loop.fs_stat(filepath) then
            return filepath
        end

        local parent = vim.fn.fnamemodify(dir, ":h")
        if parent == dir then
            return nil
        end

        return find_config_file(parent, filename)
    end

    local function parse_prettierrc(filepath)
        local ok, content = pcall(vim.fn.readfile, filepath)
        if not ok or not content then
            return nil
        end

        local text = table.concat(content, "\n")

        -- Try to parse as JSON
        local json_ok, data = pcall(vim.fn.json_decode, text)
        if json_ok and data and data.printWidth then
            return tonumber(data.printWidth)
        end

        -- Fallback: simple pattern matching for printWidth
        local printwidth = text:match('"printWidth"%s*:%s*(%d+)')
        if printwidth then
            return tonumber(printwidth)
        end

        return nil
    end

    local function parse_editorconfig(filepath)
        local ok, lines = pcall(vim.fn.readfile, filepath)
        if not ok or not lines then
            return nil
        end

        local in_markdown_section = false
        local in_global_section = true
        local max_line_length = nil

        for _, line in ipairs(lines) do
            line = vim.trim(line)

            -- Skip comments and empty lines
            if line:match("^#") or line == "" then
                goto continue
            end

            -- Check for section headers
            if line:match("^%[.+%]$") then
                local section = line:match("^%[(.+)%]$")
                in_markdown_section = section:match("%.md$") or section:match("markdown") or section == "*"
                in_global_section = section == "*"
                goto continue
            end

            -- Look for max_line_length in relevant sections
            if (in_markdown_section or in_global_section) and line:match("^max_line_length") then
                local value = line:match("max_line_length%s*=%s*(%d+)")
                if value then
                    max_line_length = tonumber(value)
                    if in_markdown_section then
                        -- Prefer markdown-specific setting
                        return max_line_length
                    end
                end
            end

            ::continue::
        end

        return max_line_length
    end

    -- Try .prettierrc first
    local prettierrc_path = find_config_file(start_path, ".prettierrc")
    if prettierrc_path then
        local printwidth = parse_prettierrc(prettierrc_path)
        if printwidth then
            return printwidth
        end
    end

    -- Try .prettierrc.json
    local prettierrc_json_path = find_config_file(start_path, ".prettierrc.json")
    if prettierrc_json_path then
        local printwidth = parse_prettierrc(prettierrc_json_path)
        if printwidth then
            return printwidth
        end
    end

    -- Try .editorconfig
    local editorconfig_path = find_config_file(start_path, ".editorconfig")
    if editorconfig_path then
        local printwidth = parse_editorconfig(editorconfig_path)
        if printwidth then
            return printwidth
        end
    end

    return nil
end

return M
