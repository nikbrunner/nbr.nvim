local M = {}

---Finds a pattern in a line of a file and replaces it with a value
---@param filepath string
---@param pattern string
---@param value string
function M.update_line_in_file(filepath, pattern, value)
    -- First check if file exists and is readable
    if not vim.loop.fs_stat(filepath) then
        vim.notify("File does not exist: " .. filepath, vim.log.levels.ERROR)
        return
    end

    -- Read file safely with pcall
    local ok, lines = pcall(vim.fn.readfile, filepath)
    if not ok or not lines then
        vim.notify("Failed to read file: " .. filepath, vim.log.levels.ERROR)
        return
    end

    -- Process lines
    lines = vim.tbl_map(function(line)
        if vim.fn.match(line, pattern) ~= -1 then
            line = vim.fn.substitute(line, '".*"', value, "")
        end
        return line
    end, lines)

    -- Use a delay and write file safely with pcall
    vim.defer_fn(function()
        local write_ok, err = pcall(vim.fn.writefile, lines, filepath)
        if not write_ok then
            vim.notify("Failed to write file: " .. filepath .. " - " .. (err or "unknown error"), vim.log.levels.ERROR)
        end
    end, 500)
end

---Syncs the wezterm colorscheme with the current nvim colorscheme (if configured)
---@param config VinConfig
---@param colorscheme string
function M.sync_wezterm_colorscheme(config, colorscheme)
    local colorscheme_config = config.colorscheme_config_map[colorscheme]

    if not colorscheme_config or not colorscheme_config.wezterm then
        vim.notify("Colorscheme not configured for wezterm")
        return
    end

    local wezterm_schemes_file = config.pathes.config.wezterm .. "/.current_schemes.lua"

    -- Determine current background mode
    local current_background = vim.o.background

    -- Get current light and dark colorschemes from config
    local light_colorscheme = config.colorscheme_light
    local dark_colorscheme = config.colorscheme_dark

    local fallback_light_colorscheme_wezterm = "Black Atom — JPN ∷ Koyo Hiru"
    local fallback_dark_colorscheme_wezterm = "Black Atom — JPN ∷ Koyo Yoru"

    -- Get wezterm mappings for both
    local light_wezterm = config.colorscheme_config_map[light_colorscheme]
            and config.colorscheme_config_map[light_colorscheme].wezterm
        or fallback_light_colorscheme_wezterm
    local dark_wezterm = config.colorscheme_config_map[dark_colorscheme]
            and config.colorscheme_config_map[dark_colorscheme].wezterm
        or fallback_dark_colorscheme_wezterm

    -- If we're manually changing to a specific colorscheme, update the appropriate mode
    if current_background == "light" then
        light_wezterm = colorscheme_config.wezterm
    else
        dark_wezterm = colorscheme_config.wezterm
    end

    local content = string.format(
        [[-- This file is automatically generated by Neovim
-- Contains current colorscheme mappings for light and dark modes
return {
    light = "%s",
    dark = "%s"
}]],
        light_wezterm,
        dark_wezterm
    )

    -- Write the file safely with pcall
    local write_ok, err = pcall(vim.fn.writefile, vim.split(content, "\n"), wezterm_schemes_file)
    if not write_ok then
        vim.notify("Failed to write wezterm schemes file: " .. (err or "unknown error"), vim.log.levels.ERROR)
    end
end

---Opens a daily note from the specified workspace in a vertical split
---@param workspace_name string The name of the Obsidian workspace
---@param split_cmd? string The split command to use (defaults to "vsplit")
---@return boolean success Whether the note was opened successfully
function M.open_daily_note(workspace_name, split_cmd)
    local obsidian = require("obsidian")
    split_cmd = split_cmd or "vsplit"

    -- Get the client instance
    local client = obsidian.get_client()
    if not client then
        vim.notify("Obsidian client not available", vim.log.levels.ERROR, { title = "Daily Notes" })
        return false
    end

    -- Set the workspace as needed
    local current_ws = client.current_workspace
    if current_ws.name ~= workspace_name then
        -- Try to switch to the requested workspace
        local found = false
        for _, ws in ipairs(client.opts.workspaces or {}) do
            if ws.name == workspace_name then
                client:switch_workspace(workspace_name)
                found = true
                break
            end
        end

        if not found then
            vim.notify("Workspace '" .. workspace_name .. "' not found", vim.log.levels.ERROR, { title = "Daily Notes" })
            return false
        end
    end

    -- Get the daily note and open it in a vertical split
    -- This will create the note if it doesn't exist
    local note = client:daily(0) -- 0 for today, offset_days must be provided

    if note and note.path then
        local daily_note_path = note.path.filename
        vim.cmd(split_cmd .. " " .. vim.fn.fnameescape(daily_note_path))
        vim.notify("Opened today's " .. workspace_name .. " note", vim.log.levels.INFO, { title = "Daily Notes" })
        return true
    else
        vim.notify("Failed to open today's " .. workspace_name .. " note", vim.log.levels.ERROR, { title = "Daily Notes" })
        return false
    end
end

return M
