# topic: Query key generation

- file: 2024-08-09.12-14-54.188.md

Write your queries after ðŸ’¬:. Use `<C-g><C-g>` or :GpChatRespond to generate a response.
Response generation can be terminated by using `<C-g>s` or :GpChatStop command.
Chats are saved automatically. To delete this chat, use `<C-g>d` or :GpChatDelete.
Be cautious of very long chats. Start a fresh chat by using `<C-g>c` or :GpChatNew.

---

ðŸ’¬:
Could you help me with the queryKey generation for the useFetch hook?

```tsx
import { useEffect } from "react";
import { useQuery, UseQueryOptions } from "@tanstack/react-query";

type UseFetchOptions<Data = unknown, Error = unknown> = UseQueryOptions<Data, Error> & {
  onSuccess?: (data: Data) => void;
  onError?: (error: Error) => void;
};

export const useFetch = <Data = unknown, Err = Error>(options: UseFetchOptions<Data, Err>) => {
  const query = useQuery<Data, Err>(options);

  useEffect(() => {
    if (query.isSuccess && query.data) {
      options.onSuccess?.(query.data);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps -- We only want to run this effect when the data changes
  }, [query.data]);

  useEffect(() => {
    if (query.isError && query.error) {
      options.onError?.(query.error as Err);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps -- We only want to run this effect when the error changes
  }, [query.error]);

  return {
    isLoading: query.isLoading,
    data: query.data,
    error: query.error,
    refresh: query.refetch
  };
};

```

```tsx

  // The goal is to create a unique query key for the useFetch hook.
  // I want to encode the deep objects to a unique string, so that query is more readable in the devtools.
  const queryKey = useMemo(
    (brandKey: string | undefined) => {
      // todo
    },
    [brandKey]
  );

  const {
    data: { products = null, totalFiltered = 0, variantsLength = 0, usedSearchTerm = debouncedSearchTerm } = {},
    isLoading
  } = useFetch({
    queryKey: [
      "productFinderPartial",
      currency,
      activeFilters,
      debouncedSearchTerm,
      assortmentPriceSettings,
      productType,
      brandKey,
      viewMode,
      specConfig
    ],
    queryFn: async () => {
      const specFilters = getProductFiltersFromActiveFilters(activeFilters, specConfig.filterConfig);
      const nextProductSpecFilters = brandKey
        ? [...specFilters, { key: ProductSpecKey.BrandKey, value: brandKey }]
        : specFilters;

      const { results: products, totalFiltered } = await getProducts<typeof productType>(
        currency,
        assortmentPriceSettings,
        nextProductSpecFilters,
        debouncedSearchTerm
      );

      const variantsLength = products.flatMap(getProductVariants).length;

      return { products, totalFiltered, variantsLength, usedSearchTerm: debouncedSearchTerm };
    },
    enabled: wereDefaultActiveFiltersEvaluated
  });
  ```

ðŸ¤–:[ChatClaude-3-5-Sonnet]
Certainly! I'd be happy to help you with generating a unique and readable queryKey for your useFetch hook. The goal is to create a string that represents the deep objects in a way that's both unique and human-readable. Here's an approach you can use:

```typescript
import { useMemo } from 'react';
import { stringify } from 'query-string';

const useFetchQueryKey = (
  currency: string,
  activeFilters: object,
  debouncedSearchTerm: string,
  assortmentPriceSettings: object,
  productType: string,
  brandKey: string | undefined,
  viewMode: string,
  specConfig: object
) => {
  return useMemo(() => {
    const queryKeyObj = {
      currency,
      activeFilters: stringify(activeFilters),
      searchTerm: debouncedSearchTerm,
      priceSettings: stringify(assortmentPriceSettings),
      productType,
      brandKey: brandKey || 'none',
      viewMode,
      specConfig: stringify(specConfig)
    };

    const queryKeyString = stringify(queryKeyObj, { sort: false });

    return ['productFinderPartial', queryKeyString];
  }, [
    currency,
    activeFilters,
    debouncedSearchTerm,
    assortmentPriceSettings,
    productType,
    brandKey,
    viewMode,
    specConfig
  ]);
};
```

Now, you can use this hook in your component like this:

```typescript
const queryKey = useFetchQueryKey(
  currency,
  activeFilters,
  debouncedSearchTerm,
  assortmentPriceSettings,
  productType,
  brandKey,
  viewMode,
  specConfig
);

const {
  data: { products = null, totalFiltered = 0, variantsLength = 0, usedSearchTerm = debouncedSearchTerm } = {},
  isLoading
} = useFetch({
  queryKey,
  queryFn: async () => {
    // ... your existing query function
  },
  enabled: wereDefaultActiveFiltersEvaluated
});
```

This approach has several benefits:

1. It uses the `query-string` library's `stringify` function to convert objects into URL-encoded strings. This ensures that deep objects are properly serialized.

2. The resulting queryKey is an array with two elements: a static string "productFinderPartial" and a dynamic string representing all the parameters. This structure is recommended by React Query for optimal performance.

3. The `useMemo` hook ensures that the queryKey is only recalculated when one of its dependencies changes.

4. By using `stringify` on the final object, we ensure that the order of properties doesn't affect the resulting string, making the key more stable.

5. The resulting string in the devtools will be human-readable, as it will look something like: `["productFinderPartial", "currency=USD&activeFilters=...&searchTerm=..."]`

Remember to install the `query-string` library if you haven't already:

```
npm install query-string
```

or

```
yarn add query-string
```

This solution should provide you with a unique, stable, and readable queryKey for your useFetch hook.


ðŸ’¬:

No I wanna do this in the `useMemo` declartion. It should convert the deep objects to a unque base64 string or something like that.

  // The goal is to create a unique query key for the useFetch hook.
  // I want to encode the deep objects to a unique string, so that query is more readable in the devtools.
  const queryKey = useMemo(
    (brandKey: string | undefined) => {
      // todo
    },
    [brandKey]
  );

ðŸ¤–:[ChatClaude-3-5-Sonnet]
I apologize for the misunderstanding. You're right, we can create a unique base64 string directly in the `useMemo` declaration. Here's a solution that encodes the deep objects into a base64 string:

```typescript
import { useMemo } from 'react';

const queryKey = useMemo(() => {
  const encodeObject = (obj: any): string => {
    if (typeof obj !== 'object' || obj === null) {
      return String(obj);
    }
    return Object.entries(obj)
      .sort(([a], [b]) => a.localeCompare(b))
      .map(([key, value]) => `${key}:${encodeObject(value)}`)
      .join(',');
  };

  const objectsToEncode = [
    currency,
    activeFilters,
    debouncedSearchTerm,
    assortmentPriceSettings,
    productType,
    brandKey,
    viewMode,
    specConfig
  ];

  const encodedString = objectsToEncode.map(encodeObject).join('|');
  const base64String = btoa(encodedString);

  return ["productFinderPartial", base64String];
}, [
  currency,
  activeFilters,
  debouncedSearchTerm,
  assortmentPriceSettings,
  productType,
  brandKey,
  viewMode,
  specConfig
]);
```

This solution does the following:

1. We define an `encodeObject` function that recursively converts any object to a string representation. It sorts object keys to ensure consistent output regardless of key order.

2. We create an array `objectsToEncode` with all the values we want to include in our queryKey.

3. We map over this array, encoding each object to a string, and join these strings with a '|' character.

4. We then convert this string to a base64 representation using `btoa()`.

5. Finally, we return an array with "productFinderPartial" as the first element and our base64 string as the second element.

This approach will give you a unique, consistent queryKey that encodes all your parameters, including deep objects, into a single base64 string. The resulting queryKey in your React Query devtools will look something like:

```
["productFinderPartial", "YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXo="]
```

This solution balances readability in the devtools (it's clear which query it is from the "productFinderPartial" prefix) with a compact representation of all parameters (in the base64 string).

Remember that this approach will create a new string (and thus a new queryKey) whenever any of the dependency values change, which is exactly what we want for proper cache invalidation with React Query.


ðŸ’¬:
I get the Error Failed to execute 'btoa' on 'Window': The string to be encoded contains characters outside of the Latin1 range.
I am working in an Electron React app.

ðŸ¤–:[ChatClaude-3-5-Sonnet]
I apologize for the oversight. You're encountering this error because `btoa()` only works with strings containing characters in the ASCII range (0-255). In an Electron React app, you might be dealing with Unicode characters, which causes this error.

Let's modify our approach to handle this issue. We'll use a custom base64 encoding function that can handle Unicode characters:

```typescript
import { useMemo } from 'react';

const queryKey = useMemo(() => {
  const encodeObject = (obj: any): string => {
    if (typeof obj !== 'object' || obj === null) {
      return String(obj);
    }
    return Object.entries(obj)
      .sort(([a], [b]) => a.localeCompare(b))
      .map(([key, value]) => `${key}:${encodeObject(value)}`)
      .join(',');
  };

  const utoa = (str: string): string => {
    return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, (_, p1) => String.fromCharCode(parseInt(p1, 16))));
  };

  const objectsToEncode = [
    currency,
    activeFilters,
    debouncedSearchTerm,
    assortmentPriceSettings,
    productType,
    brandKey,
    viewMode,
    specConfig
  ];

  const encodedString = objectsToEncode.map(encodeObject).join('|');
  const base64String = utoa(encodedString);

  return ["productFinderPartial", base64String];
}, [
  currency,
  activeFilters,
  debouncedSearchTerm,
  assortmentPriceSettings,
  productType,
  brandKey,
  viewMode,
  specConfig
]);
```

In this updated version:

1. We've added a `utoa` (Unicode to ASCII) function that first URI-encodes the string (converting Unicode characters to ASCII representations) and then applies `btoa()`.

2. We use this `utoa` function instead of `btoa()` directly.

This approach should work in your Electron React app and handle any Unicode characters that might be present in your data.

The rest of the logic remains the same:
- We still encode each object into a string representation.
- We join these encoded strings with a '|' character.
- We then convert this joined string to a base64 representation using our `utoa` function.
- Finally, we return an array with "productFinderPartial" as the first element and our base64 string as the second element.

This should resolve the Unicode character issue while still providing a unique and consistent queryKey for your useFetch hook.


ðŸ’¬:

It works but it is a pretty long string, and doesnkt improve the situation in the devtools.

What I want to achieve is something like this:
["productFinderPartial", "currency=EUR", "activeFilters=<encodedShortSTring>", ...]

ðŸ¤–:[ChatClaude-3-5-Sonnet]
I understand now. You want a more readable and concise representation in the devtools, with each parameter having its own encoded short string. Let's modify the approach to achieve this:

```typescript
import { useMemo } from 'react';

const queryKey = useMemo(() => {
  const encodeObject = (obj: any): string => {
    if (typeof obj !== 'object' || obj === null) {
      return String(obj);
    }
    const str = JSON.stringify(obj);
    return btoa(encodeURIComponent(str)).slice(0, 10); // Take first 10 characters of base64
  };

  const encodeValue = (value: any): string => {
    if (typeof value === 'object' && value !== null) {
      return encodeObject(value);
    }
    return String(value);
  };

  const params = {
    currency,
    activeFilters,
    searchTerm: debouncedSearchTerm,
    priceSettings: assortmentPriceSettings,
    productType,
    brandKey,
    viewMode,
    specConfig
  };

  const encodedParams = Object.entries(params).map(([key, value]) => 
    `${key}=${encodeValue(value)}`
  );

  return ["productFinderPartial", ...encodedParams];
}, [
  currency,
  activeFilters,
  debouncedSearchTerm,
  assortmentPriceSettings,
  productType,
  brandKey,
  viewMode,
  specConfig
]);
```

This approach does the following:

1. We define an `encodeObject` function that converts an object to a JSON string, URI-encodes it, converts it to base64, and then takes the first 10 characters of the result. This gives us a short, unique representation of complex objects.

2. We define an `encodeValue` function that uses `encodeObject` for objects and simply converts other types to strings.

3. We create a `params` object with all our parameters.

4. We map over the entries of this `params` object, encoding each value and creating a string in the format `key=encodedValue`.

5. Finally, we return an array with "productFinderPartial" as the first element, followed by all our encoded parameter strings.

The resulting queryKey in your React Query devtools will look something like this:

```
[
  "productFinderPartial",
  "currency=EUR",
  "activeFilters=JTdCJTIyZm",
  "searchTerm=example",
  "priceSettings=JTdCJTIycH",
  "productType=shoes",
  "brandKey=nike",
  "viewMode=grid",
  "specConfig=JTdCJTIyZm"
]
```

This approach gives you:

1. A readable representation of simple values (strings, numbers).
2. Short, unique encodings for complex objects.
3. A clear structure where each parameter is separate and identifiable.

This should significantly improve readability in the devtools while still providing unique keys for React Query's caching mechanism.


ðŸ’¬:

Okay could you please built a `useProducts` hook for me? It should combine these two Snippets. I need to be this reusable.

These are the two Snippets:

```tsx
  const queryKey = React.useMemo(() => {
    const encodeObject = (obj: any): string => {
      if (typeof obj !== "object" || obj === null) {
        return String(obj);
      }
      const str = JSON.stringify(obj);
      return btoa(encodeURIComponent(str)).slice(0, 20); // Take first 10 characters of base64
    };

    const encodeValue = (value: any): string => {
      if (typeof value === "object" && value !== null) {
        return encodeObject(value);
      }
      return String(value);
    };

    const params = {
      currency,
      activeFilters,
      searchTerm: debouncedSearchTerm,
      priceSettings: assortmentPriceSettings,
      productType,
      brandKey,
      viewMode,
      specConfig
    };

    const encodedParams = Object.entries(params).map(([key, value]) => `${key}=${encodeValue(value)}`);

    return ["productFinderPartial", ...encodedParams];
  }, [
    currency,
    activeFilters,
    debouncedSearchTerm,
    assortmentPriceSettings,
    productType,
    brandKey,
    viewMode,
    specConfig
  ]);

  const {
    data: { products = null, totalFiltered = 0, variantsLength = 0, usedSearchTerm = debouncedSearchTerm } = {},
    isLoading
  } = useFetch({
    queryKey,
    queryFn: async () => {
      const specFilters = getProductFiltersFromActiveFilters(activeFilters, specConfig.filterConfig);
      const nextProductSpecFilters = brandKey
        ? [...specFilters, { key: ProductSpecKey.BrandKey, value: brandKey }]
        : specFilters;

      const { results: products, totalFiltered } = await getProducts<typeof productType>(
        currency,
        assortmentPriceSettings,
        nextProductSpecFilters,
        debouncedSearchTerm
      );

      const variantsLength = products.flatMap(getProductVariants).length;

      return { products, totalFiltered, variantsLength, usedSearchTerm: debouncedSearchTerm };
    },
    enabled: wereDefaultActiveFiltersEvaluated
  });
```

And to know where the arguments come from, I give the whole page. You can use `useSelector` to get the arguments from the store.

```tsx
import React from "react";
import { replace } from "connected-react-router";
import { chunk, isUndefined, keyBy } from "lodash";
import { useTranslation } from "react-i18next";
import { ConnectedProps } from "react-redux";
import { useLocation, useParams } from "react-router";

import { getBrandKeyLogoMap } from "../../../../commons/libs/brands";
import { getCustomerGroupConfig } from "../../../../commons/libs/config";
import { getProducts } from "../../../../commons/libs/content-service";
import { getBrandImageUrl } from "../../../../commons/libs/resource-paths";
import { getFirstVariantId, getProductVariants } from "../../../../commons/libs/specs";
import { getSpecConfig } from "../../../../commons/specs";
import { CustomBicycleFilterKey } from "../../../../commons/specs/bicycle";
import {
  ActiveFilters,
  FilterConfigConstKeys,
  FilterKey,
  getTypedFilterConfigEntries
} from "../../../../commons/specs/filters";
import {
  Category,
  CategoryMap,
  Product,
  ProductId,
  ProductKey,
  ProductSpecKey,
  ProductType
} from "../../../../commons/specs/product";
import { AssortmentType } from "../../../../commons/types/assortment";
import { GlobalLocationState } from "../../../../commons/types/location";
import { ProductFinderViewMode } from "../../../../commons/types/settings";
import * as icons from "../../../../resources/icons";
import actions from "../../actions";
import BrandImage from "../../components/BrandImage/BrandImage";
import Button from "../../components/Button/Button";
import CenteredContent from "../../components/CenteredContent/CenteredContent";
import ContentTile from "../../components/ContentTile/ContentTile";
import CurrentPageBreadcrumb from "../../components/CurrentPageBreadcrumb/CurrentPageBreadcrumb";
import Headline from "../../components/Headline/Headline";
import Icon from "../../components/Icon/Icon";
import ItemList from "../../components/ItemList/ItemList";
import LazyContent from "../../components/LazyContent/LazyContent";
import LoadingIndicator from "../../components/LoadingIndicator/LoadingIndicator";
import Paragraph from "../../components/Paragraph/Paragraph";
import ProductFilterList from "../../components/ProductFilterList/ProductFilterList";
import ProductFinderPageLayout from "../../components/ProductFinderPageLayout/ProductFinderPageLayout";
import SearchListItem from "../../components/SearchListItem/SearchListItem";
import TileGrid from "../../components/TileGrid/TileGrid";
import config from "../../config";
import { getProductFiltersFromActiveFilters } from "../../libs/filters";
import useDebounce from "../../libs/hooks/use-debounce";
import { useFetch } from "../../libs/hooks/use-fetch";
import { useMediaQuery } from "../../libs/hooks/use-media-query";
import useProductFilter from "../../libs/hooks/use-product-filter";
import useRestoreScrollPosition from "../../libs/hooks/use-restore-scroll-position";
import useSelector from "../../libs/hooks/use-selector";
import useSizingAvailability from "../../libs/hooks/use-sizing-availability";
import useVeloconnectEndpoints from "../../libs/hooks/use-veloconnect-endpoints";
import { buildPath } from "../../libs/path";
import {
  CategorizedProduct,
  createProductListContextFromProducts,
  getGroupedProductsByView,
  GroupedProductsByBrand
} from "../../libs/products";
import * as selectors from "../../libs/selectors";
import { State } from "../../reducers";
import * as routes from "../../routes";
import FilterListItemTooltipPartial from "../App/FilterListItemTooltipPartial";
import ModalContainerWithStatePartial from "../Modal/ModalContainerWithStatePartial";
import { connect } from "../utils/loop";
import { useTrackingContext } from "../utils/tracking-context";
import { VeloconnectEndpointsProvider } from "../utils/veloconnect-endpoints-context";

import FilterModalPartial from "./FilterModalPartial";
import ProductTilePartial from "./ProductTilePartial";

// Important: These sizes need to be manually synchronized to the stylings
const TITLE_GRID_HEADER_HEIGHT = 68;
const BIKE_TILE_HEIGHT = 240;
const BIKE_TILE_HEIGHT_S = 200;
const GRID_GAP = 2;

interface ProductFinderRendererProps<Type extends ProductType> {
  products: Product[] | null;
  productType: ProductType;
  brandKey?: string;
  searchTerm: string;
  viewMode: ProductFinderViewMode;
  scrollRef: React.RefObject<HTMLDivElement>;
  activeFilters: ActiveFilters<Type>;
}

const ProductFinderRenderer = React.memo(
  <Type extends ProductType>({
    products,
    productType,
    brandKey,
    searchTerm,
    viewMode,
    scrollRef,
    activeFilters
  }: ProductFinderRendererProps<Type>) => {
    const brands = useSelector(state => state.brands.available);

    const { t } = useTranslation(["commons"]);
    const breakpoints = useMediaQuery();
    const gridColumns = breakpoints.xl ? 4 : 3;

    const brandsMap = React.useMemo(() => keyBy(brands, brand => brand.key), [brands]);

    const onPushAndStoreScrollPosition = useRestoreScrollPosition(scrollRef, !!products && products.length > 0);

    const goToProduct = (dataSource: Product[] | GroupedProductsByBrand, id: ProductId, variantId?: ProductId) => {
      const state: GlobalLocationState = {
        backLabel: t("commons:productFinderPartialProductFinder.backToProductFinderButton"),
        productListContext: createProductListContextFromProducts(dataSource),
        variantId
      };
      onPushAndStoreScrollPosition(buildPath(routes.PRODUCT_DETAILS.INDEX, { id: String(id) }), state);
    };

    const renderUngroupedView = (products: Product[]) => {
      const gridRows = 2;

      return (
        <div>
          {chunk(products, gridColumns * gridRows).map((chunk, index) => (
            <LazyContent
              key={index}
              height={
                Math.ceil(chunk.length / gridColumns) * (breakpoints.xl ? BIKE_TILE_HEIGHT : BIKE_TILE_HEIGHT_S) +
                (Math.ceil(chunk.length / gridColumns) - 1) * GRID_GAP
              }
            >
              {({ isVisible }) =>
                isVisible /* Space-top modifier is needed to keep space between TileGrids in sync with space between TileGrid rows. */ ? (
                  <TileGrid columns={gridColumns} fill classNames={[index > 0 ? "u-space-top-xxxs" : ""]}>
                    {chunk.map(product => (
                      <ProductTilePartial
                        key={product[ProductKey.ProductId]}
                        product={product}
                        brandKey={brandKey}
                        activeFilters={activeFilters}
                        asCategoryViewMode={!brandKey}
                        onClick={() => goToProduct(products, product[ProductKey.ProductId], getFirstVariantId(product))}
                      />
                    ))}
                  </TileGrid>
                ) : null
              }
            </LazyContent>
          ))}
        </div>
      );
    };

    const renderGroupedView = (productType: ProductType, groupedProducts: GroupedProductsByBrand) =>
      Object.entries(groupedProducts).map(([currentBrandKey, categories]) => (
        <React.Fragment key={currentBrandKey}>
          {!brandKey && brandsMap[currentBrandKey] && (
            <ContentTile>
              <BrandImage position="center" src={getBrandImageUrl(brandsMap[currentBrandKey])} />
            </ContentTile>
          )}
          {(Object.entries(categories) as [Category, CategorizedProduct][]).map(([categoryKey, categorizedProduct]) =>
            Object.entries(categorizedProduct)
              .filter(([, categoryProducts]) => categoryProducts.length !== 0)
              .map(([engineKey, categoryProducts]) => (
                <LazyContent
                  key={`${currentBrandKey}-${categoryKey}-${engineKey}`}
                  height={
                    // Placeholder height
                    TITLE_GRID_HEADER_HEIGHT +
                    Math.ceil(categoryProducts.length / gridColumns) *
                      (breakpoints.xl ? BIKE_TILE_HEIGHT : BIKE_TILE_HEIGHT_S) +
                    (Math.ceil(categoryProducts.length / gridColumns) - 1) * GRID_GAP
                  }
                >
                  {({ isVisible }) => {
                    return (
                      isVisible && (
                        <TileGrid
                          columns={gridColumns}
                          key={`${currentBrandKey}-${categoryKey}-${engineKey}`}
                          stickyHeader
                          fill
                          header={
                            <Headline kind={breakpoints.l ? "m" : "base"}>
                              {brandsMap[currentBrandKey] && brandsMap[currentBrandKey].displayName}{" "}
                              {/* Limitation of TypeScript:
                              https://github.com/microsoft/TypeScript/issues/57388 */}
                              {t(
                                `commons:specs.${productType}.categories.${categoryKey}.${engineKey === "withEngine" ? "withEngine" : "default"}` as keyof {
                                  [T in ProductType as `commons:specs.${T}.categories.${CategoryMap[T]}.${T extends ProductType.Bicycle ? "default" | "withEngine" : "default"}`]: null;
                                }
                              )}
                            </Headline>
                          }
                        >
                          {categoryProducts.map(product => (
                            <ProductTilePartial
                              key={product[ProductKey.ProductId]}
                              product={product}
                              activeFilters={activeFilters}
                              brandKey={brandKey}
                              asCategoryViewMode={viewMode === ProductFinderViewMode.GroupedByCategoryOnly}
                              onClick={() =>
                                goToProduct(groupedProducts, product[ProductKey.ProductId], getFirstVariantId(product))
                              }
                            />
                          ))}
                        </TileGrid>
                      )
                    );
                  }}
                </LazyContent>
              ))
          )}
        </React.Fragment>
      ));

    if (products === null) {
      return (
        <CenteredContent>
          <LoadingIndicator />
        </CenteredContent>
      );
    }

    if (products && products.length === 0) {
      return (
        <CenteredContent>
          <Paragraph size="l" classNames={["u-text-center"]}>
            {t("commons:productFinderPartialProductFinder.noResultsFound")}
          </Paragraph>
        </CenteredContent>
      );
    }

    if (searchTerm) {
      return renderUngroupedView(products);
    }

    return renderGroupedView(productType, getGroupedProductsByView(products, viewMode));
  }
);

ProductFinderRenderer.displayName = "ProductFinderRenderer";

const mapStateToProps = (state: State) => ({
  brands: state.brands.available,
  activeBrands: state.brands.active,
  customization: selectors.selectInitializedSettings(state).customization,
  currency: selectors.selectInitializedSettings(state).currency,
  assortment: selectors.selectInitializedSettings(state).assortment,
  assortmentFilterSettings: selectors.selectAssortmentFilterSettings(state),
  assortmentPriceSettings: selectors.selectAssortmentPriceSettings(state),
  bodySizingEnabled: selectors.selectIsBodySizingEnabled(state),
  bodySizingNotificationsEnabled: selectors.selectIsBodySizingNotificationsEnabled(state),
  customerGroup: getCustomerGroupConfig(selectors.selectInitializedEnv(state).customerGroup)
});

const mapDispatchToProps = {
  onError: actions.error.set,
  onReplace: replace
};

const connector = connect(mapStateToProps, mapDispatchToProps);

interface OuterProps {
  backButton: () => React.ReactNode;
  isOffline: boolean;
}

type Props = ConnectedProps<typeof connector> & OuterProps;

const ProductFinderPartial = ({
  assortment,
  assortmentFilterSettings,
  assortmentPriceSettings,
  currency,
  brands,
  activeBrands,
  customization,
  onError,
  onReplace,
  backButton,
  bodySizingEnabled,
  bodySizingNotificationsEnabled,
  isOffline,
  customerGroup
}: Props) => {
  const { t, i18n } = useTranslation(["commons"]);

  /** TODO: Get productType from Product.
   * @see BCD-6701 Integrate motorcycles into content service
   */
  const productType = customerGroup.productTypes[0];
  const specConfig = getSpecConfig(productType);
  const filterConfigEntries = getTypedFilterConfigEntries(specConfig.filterConfig);

  const scrollRef = React.useRef<HTMLDivElement>(null);
  const sidebarScrollRef = React.useRef<HTMLDivElement>(null);

  const { brand: brandKey } = useParams<{ brand?: string }>();
  const { mixpanel } = useTrackingContext();
  const breakpoints = useMediaQuery();

  const location = useLocation<GlobalLocationState>();

  const [searchTerm, setSearchTerm] = React.useState(location?.state?.searchTerm ?? "");

  const veloconnectEndpoints = useVeloconnectEndpoints();

  const {
    activeFilters,
    clearAllFilters,
    clearFilter,
    clearFilters,
    error,
    filterValues,
    hasActiveFilters,
    selectedBrands,
    filterKeysWithInsufficientFilterValues,
    isFilterItemActive,
    isLoading: isFiltersLoading,
    setActiveFilters,
    wereDefaultActiveFiltersEvaluated
  } = useProductFilter({
    productType,
    assortmentFilterSettings,
    assortmentPriceSettings,
    automaticAssortmentFilter: assortment[AssortmentType.Automatic]?.filter,
    brandKey,
    shouldSetDefaultActiveFilters: location.state?.shouldSetDefaultActiveFilters
  });

  React.useEffect(() => {
    if (error) {
      onError(error);
    }
  }, [error, onError]);

  const [isAnyFilterModalOpen, setIsAnyFilterModalOpen] = React.useState(false);
  const debouncedSearchTerm = useDebounce(searchTerm, config.shared.filter.filterFetchDelay);

  const viewMode = isUndefined(brandKey)
    ? customization.productFinderViewMode
    : ProductFinderViewMode.GroupedByBrandAndCategory;

  // The goal is to create a unique query key for the useFetch hook.
  // I want to encode the deep objects to a unique string, so that query is more readable in the devtools.
  const queryKey = React.useMemo(() => {
    const encodeObject = (obj: any): string => {
      if (typeof obj !== "object" || obj === null) {
        return String(obj);
      }
      const str = JSON.stringify(obj);
      return btoa(encodeURIComponent(str)).slice(0, 20); // Take first 10 characters of base64
    };

    const encodeValue = (value: any): string => {
      if (typeof value === "object" && value !== null) {
        return encodeObject(value);
      }
      return String(value);
    };

    const params = {
      currency,
      activeFilters,
      searchTerm: debouncedSearchTerm,
      priceSettings: assortmentPriceSettings,
      productType,
      brandKey,
      viewMode,
      specConfig
    };

    const encodedParams = Object.entries(params).map(([key, value]) => `${key}=${encodeValue(value)}`);

    return ["productFinderPartial", ...encodedParams];
  }, [
    currency,
    activeFilters,
    debouncedSearchTerm,
    assortmentPriceSettings,
    productType,
    brandKey,
    viewMode,
    specConfig
  ]);

  const {
    data: { products = null, totalFiltered = 0, variantsLength = 0, usedSearchTerm = debouncedSearchTerm } = {},
    isLoading
  } = useFetch({
    queryKey,
    queryFn: async () => {
      const specFilters = getProductFiltersFromActiveFilters(activeFilters, specConfig.filterConfig);
      const nextProductSpecFilters = brandKey
        ? [...specFilters, { key: ProductSpecKey.BrandKey, value: brandKey }]
        : specFilters;

      const { results: products, totalFiltered } = await getProducts<typeof productType>(
        currency,
        assortmentPriceSettings,
        nextProductSpecFilters,
        debouncedSearchTerm
      );

      const variantsLength = products.flatMap(getProductVariants).length;

      return { products, totalFiltered, variantsLength, usedSearchTerm: debouncedSearchTerm };
    },
    enabled: wereDefaultActiveFiltersEvaluated
  });

  const brandsMap = React.useMemo(() => keyBy(brands, brand => brand.key), [brands]);

  React.useEffect(() => {
    const nextLocationState: GlobalLocationState = {
      ...(location.state ?? {}),
      activeFilters,
      searchTerm: debouncedSearchTerm
    };

    if (wereDefaultActiveFiltersEvaluated) {
      delete nextLocationState.shouldSetDefaultActiveFilters;
    }

    const nextPath = [location.pathname, location.search, location.hash].join("");

    // This doubles the number of renders in this partial and even in ProductFinderRenderer. But there seems to be no way to prevent this.
    onReplace(nextPath, nextLocationState);
    // Only update the location when the listed deps change otherwise the effect will trigger indefinitely.
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [debouncedSearchTerm, activeFilters, wereDefaultActiveFiltersEvaluated]);

  React.useEffect(() => {
    const hasActiveFiltersOrSearchTerm = Object.keys(activeFilters ?? {}).length > 0 || debouncedSearchTerm.length > 0;

    if (hasActiveFiltersOrSearchTerm) {
      mixpanel?.trackFilterChanged(activeFilters, debouncedSearchTerm);
    }
  }, [activeFilters, debouncedSearchTerm, mixpanel]);

  const onClearAllFiltersAndSearchTermAndBodyValues = () => {
    clearAllFilters(activeFilters);
    setSearchTerm("");
  };

  const sizingAvailability = useSizingAvailability(bodySizingEnabled && !isOffline);

  const renderSidebar = () => (
    <ProductFilterList
      scrollRef={sidebarScrollRef}
      header={
        <SearchListItem
          placeholder={t("commons:productFinderPartialProductFinder.searchForPlaceholder")}
          value={searchTerm}
          onChange={setSearchTerm}
        />
      }
      footer={
        <>
          <Button
            size="s"
            block
            variant="standout"
            icon={<Icon source={icons.IconSmallBin} />}
            disabled={!hasActiveFilters && searchTerm.length === 0}
            onClick={onClearAllFiltersAndSearchTermAndBodyValues}
          >
            {breakpoints.l
              ? t("commons:productFinderPartialProductFinder.deleteAllFiltersButton")
              : t("commons:productFinderPartialProductFinder.deleteFiltersButton")}
          </Button>
          <Paragraph kind="support" size={!breakpoints.xl ? "s" : "base"}>
            {isLoading
              ? t("commons:productFinderPartialProductFinder.loading")
              : t("commons:productFinderPartialProductFinder.foundModels", { count: totalFiltered })}
          </Paragraph>
        </>
      }
    >
      <ItemList>
        {filterConfigEntries
          // Hide assortment filter if device has no current assortment
          .filter(([key]) => key !== "manualAssortment" || assortment.type === AssortmentType.Manual)
          .filter(
            ([key]) =>
              key !== "automaticAssortment" ||
              (assortment.type === AssortmentType.Automatic && !assortmentFilterSettings.hideAutomaticAssortmentFilter)
          )
          // Hide this because this is handled in the FilterModalPartial for `AutomaticAssortment`
          .filter(([key]) => key !== ProductSpecKey.VeloconnectAssortment)
          // Hide brandName filter if brandKey is already defined via route parameter
          .filter(([key]) => key !== "brandName" || !brandKey)
          // Hide price filter if showPrices in settings is false
          .filter(([key]) => key !== "price" || customization.showPrices)
          .filter(
            ([key]) =>
              // TODO: This partial should be rebuilt to be more generic
              // `as` is used to cast the type to ProductType.Bicycle, because the current implementation is only used for bicycles
              (key as FilterKey<ProductType.Bicycle>) !== CustomBicycleFilterKey.Sizing ||
              bodySizingEnabled ||
              bodySizingNotificationsEnabled
          )
          .map(([key, productFilter], index) => (
            <ModalContainerWithStatePartial
              animationDuration={config.shared.transitionsDurations.fast}
              key={index}
              hideBackground={breakpoints.xl}
              position={
                // Since the `AvailabilityFilterModal` does expand and shrink its heigt,
                // we want to prevent too much layout shifting by using a different position for the `ModalContainer`
                // which keeps the top of the FilterModal in the top right but can expand to the bottom.
                breakpoints.xl && key === ProductSpecKey.AutomaticAssortment
                  ? "top-right"
                  : breakpoints.xl
                    ? "right"
                    : "center"
              }
              onOpenChange={isOpen => {
                if (isOpen) {
                  mixpanel?.trackFilterModalOpened(key);
                } else {
                  mixpanel?.trackFilterModalClosed(key);
                }
              }}
              modal={(isOpen, close) => (
                <FilterModalPartial
                  isProductLoading={isLoading}
                  isOpen={isOpen}
                  alignRight={breakpoints.xl}
                  productType={productType}
                  filterKey={key}
                  filterConfig={productFilter}
                  filterValues={filterValues}
                  activeFilters={activeFilters}
                  variantsLength={variantsLength}
                  onFilterChange={setActiveFilters}
                  clearFilter={clearFilter}
                  activeBrandsKeyMap={getBrandKeyLogoMap(activeBrands)}
                  onClose={close}
                  onOpenChange={setIsAnyFilterModalOpen}
                />
              )}
            >
              {(_isOpen, open) => {
                const titleKey = `commons:productFilterConfig.${productType}.productFilter.${key}.title` as keyof {
                  [T in ProductType as `commons:productFilterConfig.${T}.productFilter.${FilterConfigConstKeys<T>}.title`]: null;
                };

                const descriptionKey =
                  `commons:productFilterConfig.${productType}.productFilter.${key}.description` as keyof {
                    [T in ProductType as `commons:productFilterConfig.${T}.productFilter.${FilterConfigConstKeys<T>}.description`]: null;
                  };

                const title = t(titleKey);
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment -- Description is optional
                // @ts-ignore
                const description: string = i18n.exists(descriptionKey) ? t(descriptionKey) : "";

                return (
                  <FilterListItemTooltipPartial
                    filterKey={key}
                    filterConfig={productFilter}
                    filterValues={filterValues}
                    selectedBrands={selectedBrands}
                    activeFilters={activeFilters}
                    filterKeysWithInsufficientFilterValues={filterKeysWithInsufficientFilterValues}
                    label={title}
                    description={description}
                    active={
                      key === ProductSpecKey.AutomaticAssortment
                        ? isFilterItemActive(ProductSpecKey.VeloconnectAssortment, productFilter) ||
                          isFilterItemActive(key, productFilter)
                        : isFilterItemActive(key, productFilter)
                    }
                    variantsLength={variantsLength}
                    isOffline={isOffline}
                    preventTooltip={isAnyFilterModalOpen}
                    scrollRef={sidebarScrollRef}
                    onClick={open}
                    onRemove={() => {
                      mixpanel?.trackFilterCleared(key);
                      clearFilter(key);

                      // Since the FilterListItem for AutomaticAssortment, handles two spec keys, we clear both spec keys
                      if (key === ProductSpecKey.AutomaticAssortment) {
                        clearFilters([ProductSpecKey.AutomaticAssortment, ProductSpecKey.VeloconnectAssortment]);
                      }
                    }}
                    disabledReason={
                      (key as FilterKey<ProductType.Bicycle>) === CustomBicycleFilterKey.Sizing &&
                      bodySizingEnabled &&
                      !sizingAvailability.available
                        ? t("commons:productFinderPartialProductFinder.sizingServiceUnavailable")
                        : undefined
                    }
                  />
                );
              }}
            </ModalContainerWithStatePartial>
          ))}
      </ItemList>
    </ProductFilterList>
  );

  return (
    <VeloconnectEndpointsProvider endpoints={veloconnectEndpoints}>
      <ProductFinderPageLayout
        scrollRef={scrollRef}
        headerLeft={backButton()}
        headerRight={
          brandKey ? (
            <BrandImage position="right" src={getBrandImageUrl(brandsMap[brandKey])} classNames={["u-space-top-l"]} />
          ) : (
            <CurrentPageBreadcrumb>
              {t("commons:productFinderPartialProductFinder.bikeFinderLabel")}
            </CurrentPageBreadcrumb>
          )
        }
        aside={!isFiltersLoading && renderSidebar()}
      >
        <ProductFinderRenderer
          products={products}
          activeFilters={activeFilters}
          productType={productType}
          brandKey={brandKey}
          searchTerm={usedSearchTerm}
          viewMode={viewMode}
          scrollRef={scrollRef}
        />
      </ProductFinderPageLayout>
    </VeloconnectEndpointsProvider>
  );
};

export default connector(ProductFinderPartial);
```

ðŸ¤–:[ChatClaude-3-5-Sonnet]
Certainly! I'll create a `useProducts` hook that combines the functionality from the two snippets you provided. This hook will encapsulate the query key generation and the data fetching logic. Here's the implementation:

```typescript
import React from 'react';
import { useQuery } from '@tanstack/react-query';
import { getProducts, getProductVariants } from '../../../../commons/libs/content-service';
import { getProductFiltersFromActiveFilters } from '../../libs/filters';
import { ProductSpecKey, ProductType } from '../../../../commons/specs/product';
import { ActiveFilters } from '../../../../commons/specs/filters';
import { ProductFinderViewMode } from '../../../../commons/types/settings';

interface UseProductsOptions<Type extends ProductType> {
  currency: string;
  activeFilters: ActiveFilters<Type>;
  debouncedSearchTerm: string;
  assortmentPriceSettings: any;
  productType: ProductType;
  brandKey?: string;
  viewMode: ProductFinderViewMode;
  specConfig: any;
  wereDefaultActiveFiltersEvaluated: boolean;
}

export function useProducts<Type extends ProductType>({
  currency,
  activeFilters,
  debouncedSearchTerm,
  assortmentPriceSettings,
  productType,
  brandKey,
  viewMode,
  specConfig,
  wereDefaultActiveFiltersEvaluated
}: UseProductsOptions<Type>) {
  const queryKey = React.useMemo(() => {
    const encodeObject = (obj: any): string => {
      if (typeof obj !== "object" || obj === null) {
        return String(obj);
      }
      const str = JSON.stringify(obj);
      return btoa(encodeURIComponent(str)).slice(0, 20);
    };

    const encodeValue = (value: any): string => {
      if (typeof value === "object" && value !== null) {
        return encodeObject(value);
      }
      return String(value);
    };

    const params = {
      currency,
      activeFilters,
      searchTerm: debouncedSearchTerm,
      priceSettings: assortmentPriceSettings,
      productType,
      brandKey,
      viewMode,
      specConfig
    };

    const encodedParams = Object.entries(params).map(([key, value]) => `${key}=${encodeValue(value)}`);

    return ["productFinderPartial", ...encodedParams];
  }, [
    currency,
    activeFilters,
    debouncedSearchTerm,
    assortmentPriceSettings,
    productType,
    brandKey,
    viewMode,
    specConfig
  ]);

  const { data, isLoading } = useQuery({
    queryKey,
    queryFn: async () => {
      const specFilters = getProductFiltersFromActiveFilters(activeFilters, specConfig.filterConfig);
      const nextProductSpecFilters = brandKey
        ? [...specFilters, { key: ProductSpecKey.BrandKey, value: brandKey }]
        : specFilters;

      const { results: products, totalFiltered } = await getProducts<typeof productType>(
        currency,
        assortmentPriceSettings,
        nextProductSpecFilters,
        debouncedSearchTerm
      );

      const variantsLength = products.flatMap(getProductVariants).length;

      return { products, totalFiltered, variantsLength, usedSearchTerm: debouncedSearchTerm };
    },
    enabled: wereDefaultActiveFiltersEvaluated
  });

  return {
    products: data?.products ?? null,
    totalFiltered: data?.totalFiltered ?? 0,
    variantsLength: data?.variantsLength ?? 0,
    usedSearchTerm: data?.usedSearchTerm ?? debouncedSearchTerm,
    isLoading
  };
}
```

Now you can use this hook in your component like this:

```typescript
import { useProducts } from './useProducts';

// Inside your component
const {
  products,
  totalFiltered,
  variantsLength,
  usedSearchTerm,
  isLoading
} = useProducts({
  currency,
  activeFilters,
  debouncedSearchTerm,
  assortmentPriceSettings,
  productType,
  brandKey,
  viewMode,
  specConfig,
  wereDefaultActiveFiltersEvaluated
});
```

This hook encapsulates the logic for generating the query key and fetching the products. It returns the same data structure as your original code, making it easy to integrate into your existing component.

To use this hook, you'll need to pass in all the required parameters from your component's props or state. The hook will handle the memoization of the query key and the data fetching logic internally.

This approach makes your code more modular and reusable, as you can now use this hook in any component that needs to fetch products with similar parameters.


ðŸ’¬:
Instead of `useQuery` please use `useFetch` which is a wrapper around `useQuery` with some additional features.

```tsx
import { useEffect } from "react";
import { useQuery, UseQueryOptions } from "@tanstack/react-query";

type UseFetchOptions<Data = unknown, Error = unknown> = UseQueryOptions<Data, Error> & {
  onSuccess?: (data: Data) => void;
  onError?: (error: Error) => void;
};

export const useFetch = <Data = unknown, Err = Error>(options: UseFetchOptions<Data, Err>) => {
  const query = useQuery<Data, Err>(options);

  useEffect(() => {
    if (query.isSuccess && query.data) {
      options.onSuccess?.(query.data);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps -- We only want to run this effect when the data changes
  }, [query.data]);

  useEffect(() => {
    if (query.isError && query.error) {
      options.onError?.(query.error as Err);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps -- We only want to run this effect when the error changes
  }, [query.error]);

  return {
    isLoading: query.isLoading,
    data: query.data,
    error: query.error,
    refresh: query.refetch
  };
};
```

ðŸ¤–:[ChatClaude-3-5-Sonnet]
Certainly! I'll modify the `useProducts` hook to use `useFetch` instead of `useQuery`. Here's the updated version:

```typescript
import React from 'react';
import { useFetch } from '../../libs/hooks/use-fetch';
import { getProducts, getProductVariants } from '../../../../commons/libs/content-service';
import { getProductFiltersFromActiveFilters } from '../../libs/filters';
import { ProductSpecKey, ProductType } from '../../../../commons/specs/product';
import { ActiveFilters } from '../../../../commons/specs/filters';
import { ProductFinderViewMode } from '../../../../commons/types/settings';

interface UseProductsOptions<Type extends ProductType> {
  currency: string;
  activeFilters: ActiveFilters<Type>;
  debouncedSearchTerm: string;
  assortmentPriceSettings: any;
  productType: ProductType;
  brandKey?: string;
  viewMode: ProductFinderViewMode;
  specConfig: any;
  wereDefaultActiveFiltersEvaluated: boolean;
  onSuccess?: (data: any) => void;
  onError?: (error: any) => void;
}

export function useProducts<Type extends ProductType>({
  currency,
  activeFilters,
  debouncedSearchTerm,
  assortmentPriceSettings,
  productType,
  brandKey,
  viewMode,
  specConfig,
  wereDefaultActiveFiltersEvaluated,
  onSuccess,
  onError
}: UseProductsOptions<Type>) {
  const queryKey = React.useMemo(() => {
    const encodeObject = (obj: any): string => {
      if (typeof obj !== "object" || obj === null) {
        return String(obj);
      }
      const str = JSON.stringify(obj);
      return btoa(encodeURIComponent(str)).slice(0, 20);
    };

    const encodeValue = (value: any): string => {
      if (typeof value === "object" && value !== null) {
        return encodeObject(value);
      }
      return String(value);
    };

    const params = {
      currency,
      activeFilters,
      searchTerm: debouncedSearchTerm,
      priceSettings: assortmentPriceSettings,
      productType,
      brandKey,
      viewMode,
      specConfig
    };

    const encodedParams = Object.entries(params).map(([key, value]) => `${key}=${encodeValue(value)}`);

    return ["productFinderPartial", ...encodedParams];
  }, [
    currency,
    activeFilters,
    debouncedSearchTerm,
    assortmentPriceSettings,
    productType,
    brandKey,
    viewMode,
    specConfig
  ]);

  const { data, isLoading, error, refresh } = useFetch({
    queryKey,
    queryFn: async () => {
      const specFilters = getProductFiltersFromActiveFilters(activeFilters, specConfig.filterConfig);
      const nextProductSpecFilters = brandKey
        ? [...specFilters, { key: ProductSpecKey.BrandKey, value: brandKey }]
        : specFilters;

      const { results: products, totalFiltered } = await getProducts<typeof productType>(
        currency,
        assortmentPriceSettings,
        nextProductSpecFilters,
        debouncedSearchTerm
      );

      const variantsLength = products.flatMap(getProductVariants).length;

      return { products, totalFiltered, variantsLength, usedSearchTerm: debouncedSearchTerm };
    },
    enabled: wereDefaultActiveFiltersEvaluated,
    onSuccess,
    onError
  });

  return {
    products: data?.products ?? null,
    totalFiltered: data?.totalFiltered ?? 0,
    variantsLength: data?.variantsLength ?? 0,
    usedSearchTerm: data?.usedSearchTerm ?? debouncedSearchTerm,
    isLoading,
    error,
    refresh
  };
}
```

This updated version of `useProducts` uses `useFetch` instead of `useQuery`. It includes the following changes:

1. We've imported `useFetch` from your custom hooks directory.
2. We've added `onSuccess` and `onError` callbacks to the `UseProductsOptions` interface.
3. We're now using `useFetch` instead of `useQuery`, passing along the `onSuccess` and `onError` callbacks.
4. We're returning `error` and `refresh` from `useFetch` in addition to the other data.

You can now use this hook in your component like this:

```typescript
import { useProducts } from './useProducts';

// Inside your component
const {
  products,
  totalFiltered,
  variantsLength,
  usedSearchTerm,
  isLoading,
  error,
  refresh
} = useProducts({
  currency,
  activeFilters,
  debouncedSearchTerm,
  assortmentPriceSettings,
  productType,
  brandKey,
  viewMode,
  specConfig,
  wereDefaultActiveFiltersEvaluated,
  onSuccess: (data) => {
    // Handle success
  },
  onError: (error) => {
    // Handle error
  }
});
```

This implementation takes advantage of the `useFetch` hook's additional features, such as the `onSuccess` and `onError` callbacks, while maintaining the same functionality as before.


ðŸ’¬:

Would it somehow be possible to make the first queryKey Argument typesafe? I want to unsure, that requests in different places use the same queryKey. 

I am only talking about the first argument like "productFinder" or something like that. Preferably a Unition Type

```tsx
import { useEffect } from "react";
import { useQuery, UseQueryOptions } from "@tanstack/react-query";

type UseFetchOptions<Data = unknown, Error = unknown> = UseQueryOptions<Data, Error> & {
  onSuccess?: (data: Data) => void;
  onError?: (error: Error) => void;
};

export const useFetch = <Data = unknown, Err = Error>(options: UseFetchOptions<Data, Err>) => {
  const query = useQuery<Data, Err>(options);

  useEffect(() => {
    if (query.isSuccess && query.data) {
      options.onSuccess?.(query.data);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps -- We only want to run this effect when the data changes
  }, [query.data]);

  useEffect(() => {
    if (query.isError && query.error) {
      options.onError?.(query.error as Err);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps -- We only want to run this effect when the error changes
  }, [query.error]);

  return {
    isLoading: query.isLoading,
    data: query.data,
    error: query.error,
    refresh: query.refetch
  };
};
```

ðŸ¤–:[ChatClaude-3-5-Sonnet]
Certainly! We can make the first argument of the queryKey type-safe by using a union type and modifying the `UseFetchOptions` type. Here's how we can do it:

1. First, let's define a union type for all possible query keys:

```typescript
export type QueryKeyPrefix = 
  | "productFinder"
  | "productDetails"
  | "brandList"
  // Add more query key prefixes as needed
;
```

2. Now, let's modify the `UseFetchOptions` type to include this type-safe queryKey:

```typescript
import { UseQueryOptions } from "@tanstack/react-query";

type UseFetchOptions<Data = unknown, Error = unknown> = Omit<UseQueryOptions<Data, Error>, 'queryKey'> & {
  queryKey: [QueryKeyPrefix, ...any[]];
  onSuccess?: (data: Data) => void;
  onError?: (error: Error) => void;
};
```

3. Update the `useFetch` hook to use this new type:

``` itypescript
import { useEffect } from "react";
import { useQuery } from "@tanstack/react-query";

export const useFetch = <Data = unknown, Err = Error>(options: UseFetchOptions<Data, Err>) => {
  const query = useQuery<Data, Err>(options);

  useEffect(() => {
    if (query.isSuccess && query.data) {
      options.onSuccess?.(query.data);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [query.data]);

  useEffect(() => {
    if (query.isError && query.error) {
      options.onError?.(query.error as Err);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [query.error]);

  return {
    isLoading: query.isLoading,
    data: query.data,
    error: query.error,
    refresh: query.refetch
  };
};
```

Now, when using the `useFetch` hook, you'll need to provide a queryKey that starts with one of the defined `QueryKeyPrefix` values. Here's how you would use it in the `useProducts` hook:

```typescript
export function useProducts<Type extends ProductType>({
  // ... other parameters
}: UseProductsOptions<Type>) {
  const queryKey = React.useMemo(() => {
    // ... existing logic to generate encodedParams

    return ["productFinder" as const, ...encodedParams];
  }, [
    // ... dependencies
  ]);

  const { data, isLoading, error, refresh } = useFetch({
    queryKey,
    queryFn: async () => {
      // ... existing query function
    },
    enabled: wereDefaultActiveFiltersEvaluated,
    onSuccess,
    onError
  });

  // ... rest of the hook
}
```

By using `as const` when defining the first element of the queryKey array, TypeScript will infer the literal type "productFinder" instead of the more general string type.

This approach ensures that:

1. The first argument of queryKey is always one of the predefined `QueryKeyPrefix` values.
2. Different parts of your application consistently use the same query key prefixes.
3. You get TypeScript autocompletion and type checking when defining query keys.

If you try to use an undefined prefix, TypeScript will show an error, helping prevent inconsistencies across your application.


ðŸ’¬:

Build `useProduct` in the same maner for this Snippet, as `useProducts`:

```tsx

  const { isLoading: isLoading, data: { product, productVariant, specFormatter } = {} } = useFetch({
    queryKey: ["product", productId, variantId, currency],
    queryFn: async () => {
      const product = await getProduct(productId, currency, assortmentPriceSettings);

      const actualVariantId = variantId ?? getFirstVariantId(product);
      const productVariant = getStandaloneProductVariant(
        product,
        product[ProductKey.Variants].find(variant => variant[ProductKey.VariantId] === actualVariantId)
      );

      const productType = product[ProductKey.ProductType];
      const specConfig = getSpecConfig(productType);

      const specFormatter = getSpecFormatter(productType, specConfig.specDefinitions, i18n);

      return { product, productVariant, specFormatter };
    },
    onSuccess: ({ product }) => {
      onProductLoad?.(product);
    },
    onError: error => onError(error)
  });
```

```tsx
import { getProducts } from "../../../../commons/libs/content-service";
import { getProductVariants } from "../../../../commons/libs/specs";
import { ActiveFilters } from "../../../../commons/specs/filters";
import { ProductSpecKey, ProductType, SpecConfig } from "../../../../commons/specs/product";
import { Currency } from "../../../../commons/types/currency";
import { ProductFinderViewMode } from "../../../../commons/types/settings";
import { getProductFiltersFromActiveFilters } from "../../libs/filters";
import useFetch from "../../libs/hooks/use-fetch";
import { selectAssortmentPriceSettings } from "../selectors";

import useSelector from "./use-selector";

interface UseProductsOptions<Type extends ProductType> {
  productType: ProductType;
  specConfig: SpecConfig<Type>;
  currency: Currency;
  activeFilters: ActiveFilters<Type>;
  searchTerm: string;
  brandKey?: string;
  viewMode: ProductFinderViewMode;
  enabled: boolean;
  onSuccess?: (data: any) => void;
  onError?: (error: any) => void;
}

const useProducts = <Type extends ProductType>({
  productType,
  specConfig,
  currency,
  activeFilters,
  searchTerm,
  brandKey,
  viewMode,
  enabled,
  onSuccess,
  onError
}: UseProductsOptions<Type>) => {
  const assortmentPriceSettings = useSelector(selectAssortmentPriceSettings);

  // TODO: The constructed `queryKey` is because of the deeply nested `activeFilters` object pretty long and spams up the dev tools.
  // It would be cool if we somehow encode these deep objects into a single very short unique string key, so we `react-query` can still have a unique identifier,
  // but the dev tools are not filled up with these huge objects.
  // Also read this: [Effective React Query Keys | TkDodo's blog](https://tkdodo.eu/blog/effective-react-query-keys)
  const { data, isLoading, error, refresh } = useFetch({
    queryKey: [
      "products",
      productType,
      brandKey,
      activeFilters,
      currency,
      searchTerm,
      assortmentPriceSettings,
      viewMode,
      specConfig
    ],
    // To prevent devices which never turn off from filling up the cache too much,
    // we enable the garbabage collection time after 24 hours to clean up the cache
    gcTime: 24 * 60 * 60 * 1000,
    queryFn: async () => {
      const specFilters = getProductFiltersFromActiveFilters(activeFilters, specConfig.filterConfig);
      const nextProductSpecFilters = brandKey
        ? [...specFilters, { key: ProductSpecKey.BrandKey, value: brandKey }]
        : specFilters;

      const { results: products, totalFiltered } = await getProducts<Type>(
        currency,
        assortmentPriceSettings,
        nextProductSpecFilters,
        searchTerm
      );

      const variantsLength = products.flatMap(getProductVariants).length;

      return { products, totalFiltered, variantsLength, usedSearchTerm: searchTerm };
    },
    enabled,
    onSuccess,
    onError
  });

  return {
    products: data?.products ?? null,
    totalFiltered: data?.totalFiltered ?? 0,
    variantsLength: data?.variantsLength ?? 0,
    usedSearchTerm: data?.usedSearchTerm ?? searchTerm,
    isLoading,
    error,
    refresh
  };
};

export default useProducts;
```

ðŸ¤–:[ChatClaude-3-5-Sonnet]
Certainly! I'll create a `useProduct` hook based on the provided snippet and following the same pattern as `useProducts`. Here's the implementation:

```typescript
import { useMemo } from 'react';
import { useFetch } from '../../libs/hooks/use-fetch';
import { getProduct, getStandaloneProductVariant } from '../../../../commons/libs/content-service';
import { getFirstVariantId, getSpecFormatter } from '../../../../commons/libs/specs';
import { ProductKey, ProductType } from '../../../../commons/specs/product';
import { Currency } from '../../../../commons/types/currency';
import { getSpecConfig } from '../../../../commons/specs';
import { i18n } from 'i18next';

interface UseProductOptions {
  productId: string;
  variantId?: string;
  currency: Currency;
  assortmentPriceSettings: any;
  enabled?: boolean;
  onSuccess?: (data: { product: any; productVariant: any; specFormatter: any }) => void;
  onError?: (error: any) => void;
}

const useProduct = ({
  productId,
  variantId,
  currency,
  assortmentPriceSettings,
  enabled = true,
  onSuccess,
  onError
}: UseProductOptions) => {
  const queryKey = useMemo(
    () => ["product", productId, variantId, currency],
    [productId, variantId, currency]
  );

  const { data, isLoading, error, refresh } = useFetch({
    queryKey,
    queryFn: async () => {
      const product = await getProduct(productId, currency, assortmentPriceSettings);

      const actualVariantId = variantId ?? getFirstVariantId(product);
      const productVariant = getStandaloneProductVariant(
        product,
        product[ProductKey.Variants].find(variant => variant[ProductKey.VariantId] === actualVariantId)
      );

      const productType = product[ProductKey.ProductType] as ProductType;
      const specConfig = getSpecConfig(productType);

      const specFormatter = getSpecFormatter(productType, specConfig.specDefinitions, i18n);

      return { product, productVariant, specFormatter };
    },
    enabled,
    onSuccess: (data) => {
      onSuccess?.(data);
    },
    onError: (err) => {
      onError?.(err);
    }
  });

  return {
    product: data?.product ?? null,
    productVariant: data?.productVariant ?? null,
    specFormatter: data?.specFormatter ?? null,
    isLoading,
    error,
    refresh
  };
};

export default useProduct;
```

To use this hook, you would do something like this:

```typescript
const {
  product,
  productVariant,
  specFormatter,
  isLoading,
  error,
  refresh
} = useProduct({
  productId,
  variantId,
  currency,
  assortmentPriceSettings,
  onSuccess: ({ product }) => {
    // Handle success
    onProductLoad?.(product);
  },
  onError: (error) => {
    // Handle error
    onError(error);
  }
});
```

This `useProduct` hook:

1. Uses `useMemo` to create a stable `queryKey`.
2. Uses `useFetch` to handle the data fetching, caching, and state management.
3. Provides type-safe options and return values.
4. Handles the product, variant, and spec formatter logic internally.
5. Provides loading state, error handling, and a refresh function.

The hook is now more reusable and encapsulates all the logic related to fetching and processing a single product. It also follows the same pattern as `useProducts`, making it consistent with your existing code structure.


ðŸ’¬:

