# topic: Tap dance troubleshooting

- file: 2024-05-13.21-48-44.674.md

Write your queries after 🗨:. Use `<C-g><C-g>` or :GpChatRespond to generate a response.
Response generation can be terminated by using `<C-g>s` or :GpChatStop command.
Chats are saved automatically. To delete this chat, use `<C-g>d` or :GpChatDelete.
Be cautious of very long chats. Start a fresh chat by using `<C-g>c` or :GpChatNew.

---

🗨:

I have a problem with the tapdance on the extend layer (EXT). The tab action seems to work, but when i use the hold action, it seems to be stuck in the associated modifier mode. For example if i press EXT+A the command modifier gets stucked, although i released the keys. I am guessing the reset is not correct.

I wanna keep the generic helper functions like `custom_handle_tap_dance` & `custom_reset_tap_dance` because it is always the same pattern. I think the fault lies in the code of of the reset function maybe.

The goal is the following:

- EXT+a:
  - tab: -> LGUI(KEY_A)
  - hold: -> LGUI
- EXT+s:
  - tab: -> LGUI(KEY_S)
  - hold: -> LALT
- EXT+d:
  - tab: -> LGUI(KEY_D)
  - hold: -> LCTL
- EXT+f:
  - tab: -> LGUI(KEY_F)
  - hold: -> LSFT

`keymap.c`

```c
/*
Copyright 2019 @foostan
Copyright 2020 Drashna Jaelre <@drashna>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include QMK_KEYBOARD_H

enum layers {
    //
    LY_BAS,
    LY_EXT,
    LY_SYM,
    LY_NUM,
    LY_FUN,
    LY_MED
};

enum custom_keycodes {
    SS_TILD_SLSH = SAFE_RANGE,
};

enum tap_dance_codes {
    //
    TD_EXT_GUI_A,
    TD_EXT_GUI_S,
    TD_EXT_GUI_D,
    TD_EXT_GUI_F
};

// KEYMAP ===============================================================================
// clang-format off
const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = {
[LY_BAS] = LAYOUT_split_3x5_3(
//    ┌───────────┬───────────┬────────────────┬─────────────────┬─────────────────┐   ┌──────────────────┬─────────────────┬────────────────┬───────────┬───────────┐
//    │     q     │     w     │       e        │        r        │        t        │   │        y         │        u        │       i        │     o     │     p     │
//    ├───────────┼───────────┼────────────────┼─────────────────┼─────────────────┤   ├──────────────────┼─────────────────┼────────────────┼───────────┼───────────┤
//    │     a     │     s     │       d        │        f        │        g        │   │        h         │        j        │       k        │     l     │     ;     │
//    ├───────────┼───────────┼────────────────┼─────────────────┼─────────────────┤   ├──────────────────┼─────────────────┼────────────────┼───────────┼───────────┤
//    │ LGUI_T(z) │ LALT_T(x) │   LCTL_T(c)    │    LSFT_T(v)    │        b        │   │        n         │    RSFT_T(m)    │   RCTL_T(,)    │ LALT_T(.) │ RGUI_T(/) │
//    └───────────┴───────────┼────────────────┼─────────────────┼─────────────────┤   ├──────────────────┼─────────────────┼────────────────┼───────────┴───────────┘
//                            │ LT(LY_NUM, no) │ LT(LY_SYM, esc) │ LT(LY_EXT, spc) │   │ LT(LY_MED, bspc) │ LT(LY_SYM, ent) │ LT(LY_FUN, no) │
//                            └────────────────┴─────────────────┴─────────────────┘   └──────────────────┴─────────────────┴────────────────┘
  KC_Q         , KC_W         , KC_E              , KC_R               , KC_T               ,     KC_Y                , KC_U               , KC_I              , KC_O           , KC_P           ,
  KC_A         , KC_S         , KC_D              , KC_F               , KC_G               ,     KC_H                , KC_J               , KC_K              , KC_L           , KC_SCLN        ,
  LGUI_T(KC_Z) , LALT_T(KC_X) , LCTL_T(KC_C)      , LSFT_T(KC_V)       , KC_B               ,     KC_N                , RSFT_T(KC_M)       , RCTL_T(KC_COMM)   , LALT_T(KC_DOT) , RGUI_T(KC_SLSH),
                                LT(LY_NUM, KC_NO) , LT(LY_SYM, KC_ESC) , LT(LY_EXT, KC_SPC) ,     LT(LY_MED, KC_BSPC) , LT(LY_SYM, KC_ENT) , LT(LY_FUN, KC_NO)
),

[LY_EXT] = LAYOUT_split_3x5_3(
//    ┌──────────────────┬──────────────────┬──────────────────┬──────────────────┬────────────┐   ┌──────┬────────┬───────────┬───────────┬────┐
//    │     LGUI(q)      │     LGUI(w)      │     LGUI(e)      │     LGUI(r)      │  LGUI(t)   │   │  no  │ LAG(i) │  LGUI(`)  │ LGUI(tab) │ no │
//    ├──────────────────┼──────────────────┼──────────────────┼──────────────────┼────────────┤   ├──────┼────────┼───────────┼───────────┼────┤
//    │ TD(TD_EXT_GUI_A) │ TD(TD_EXT_GUI_S) │ TD(TD_EXT_GUI_D) │ TD(TD_EXT_GUI_F) │  LGUI(g)   │   │ left │  down  │    up     │   rght    │ no │
//    ├──────────────────┼──────────────────┼──────────────────┼──────────────────┼────────────┤   ├──────┼────────┼───────────┼───────────┼────┤
//    │     LGUI(z)      │     LGUI(x)      │     LGUI(c)      │     LGUI(v)      │  LGUI(b)   │   │  no  │   no   │ LSFT(tab) │    tab    │ no │
//    └──────────────────┴──────────────────┼──────────────────┼──────────────────┼────────────┤   ├──────┼────────┼───────────┼───────────┴────┘
//                                          │        no        │        no        │ TO(LY_BAS) │   │ del  │   no   │    no     │
//                                          └──────────────────┴──────────────────┴────────────┘   └──────┴────────┴───────────┘
  LGUI(KC_Q)       , LGUI(KC_W)       , LGUI(KC_E)       , LGUI(KC_R)       , LGUI(KC_T) ,     KC_NO   , LAG(KC_I) , LGUI(KC_GRV) , LGUI(KC_TAB) , KC_NO,
  TD(TD_EXT_GUI_A) , TD(TD_EXT_GUI_S) , TD(TD_EXT_GUI_D) , TD(TD_EXT_GUI_F) , LGUI(KC_G) ,     KC_LEFT , KC_DOWN   , KC_UP        , KC_RGHT      , KC_NO,
  LGUI(KC_Z)       , LGUI(KC_X)       , LGUI(KC_C)       , LGUI(KC_V)       , LGUI(KC_B) ,     KC_NO   , KC_NO     , LSFT(KC_TAB) , KC_TAB       , KC_NO,
                                        KC_NO            , KC_NO            , TO(LY_BAS) ,     KC_DEL  , KC_NO     , KC_NO
),

[LY_SYM] = LAYOUT_split_3x5_3(
//    ┌───┬───┬─────┬────────────┬─────┐   ┌─────┬────────────┬─────┬───┬───┐
//    │ ^ │ + │  #  │     %      │  $  │   │  <  │     {      │  "  │ } │ > │
//    ├───┼───┼─────┼────────────┼─────┤   ├─────┼────────────┼─────┼───┼───┤
//    │ ! │ - │  &  │     ?      │  |  │   │  =  │     [      │  '  │ ] │ : │
//    ├───┼───┼─────┼────────────┼─────┤   ├─────┼────────────┼─────┼───┼───┤
//    │ ~ │ _ │  *  │     @      │ ~/  │   │  \  │     (      │  `  │ ) │ / │
//    └───┴───┼─────┼────────────┼─────┤   ├─────┼────────────┼─────┼───┴───┘
//            │     │ TO(LY_BAS) │     │   │     │ TO(LY_BAS) │     │
//            └─────┴────────────┴─────┘   └─────┴────────────┴─────┘
  KC_CIRC , KC_PLUS , KC_HASH , KC_PERC    , KC_DLR       ,     KC_LT   , KC_LCBR    , KC_DQUO , KC_RCBR , KC_GT  ,
  KC_EXLM , KC_MINS , KC_AMPR , KC_QUES    , KC_PIPE      ,     KC_EQL  , KC_LBRC    , KC_QUOT , KC_RBRC , KC_COLN,
  KC_TILD , KC_UNDS , KC_ASTR , KC_AT      , SS_TILD_SLSH ,     KC_BSLS , KC_LPRN    , KC_GRV  , KC_RPRN , KC_SLSH,
                      KC_TRNS , TO(LY_BAS) , KC_TRNS      ,     KC_TRNS , TO(LY_BAS) , KC_TRNS
),

[LY_NUM] = LAYOUT_split_3x5_3(
//    ┌──────────┬─────────┬──────┬──────┬─────┐   ┌──────┬──────┬──────┬──────┬──────┐
//    │ HYPR(no) │ MEH(no) │  no  │  no  │ no  │   │ kp_+ │ kp_7 │ kp_8 │ kp_9 │ kp_* │
//    ├──────────┼─────────┼──────┼──────┼─────┤   ├──────┼──────┼──────┼──────┼──────┤
//    │   lgui   │  lalt   │ lctl │ lsft │ no  │   │ kp_= │ kp_4 │ kp_5 │ kp_6 │  :   │
//    ├──────────┼─────────┼──────┼──────┼─────┤   ├──────┼──────┼──────┼──────┼──────┤
//    │    no    │   no    │  no  │  no  │ no  │   │ kp_- │ kp_1 │ kp_2 │ kp_3 │ kp_/ │
//    └──────────┴─────────┼──────┼──────┼─────┤   ├──────┼──────┼──────┼──────┴──────┘
//                         │      │      │     │   │      │ kp_0 │      │
//                         └──────┴──────┴─────┘   └──────┴──────┴──────┘
  HYPR(KC_NO) , MEH(KC_NO) , KC_NO   , KC_NO   , KC_NO   ,     KC_PPLS , KC_P7 , KC_P8   , KC_P9 , KC_PAST,
  KC_LGUI     , KC_LALT    , KC_LCTL , KC_LSFT , KC_NO   ,     KC_PEQL , KC_P4 , KC_P5   , KC_P6 , KC_COLN,
  KC_NO       , KC_NO      , KC_NO   , KC_NO   , KC_NO   ,     KC_PMNS , KC_P1 , KC_P2   , KC_P3 , KC_PSLS,
                             KC_TRNS , KC_TRNS , KC_TRNS ,     KC_TRNS , KC_P0 , KC_TRNS
),

[LY_FUN] = LAYOUT_split_3x5_3(
//    ┌────┬────┬────┬────┬─────┐   ┌────┬──────┬──────┬─────────┬──────────┐
//    │ no │ f7 │ f8 │ f9 │ f12 │   │ no │  no  │  no  │ MEH(no) │ HYPR(no) │
//    ├────┼────┼────┼────┼─────┤   ├────┼──────┼──────┼─────────┼──────────┤
//    │ no │ f4 │ f5 │ f6 │ f11 │   │ no │ rsft │ rctl │  lalt   │   rgui   │
//    ├────┼────┼────┼────┼─────┤   ├────┼──────┼──────┼─────────┼──────────┤
//    │ no │ f1 │ f2 │ f3 │ f10 │   │ no │  no  │  no  │   no    │    no    │
//    └────┴────┼────┼────┼─────┤   ├────┼──────┼──────┼─────────┴──────────┘
//              │ no │ no │ no  │   │ no │  no  │  no  │
//              └────┴────┴─────┘   └────┴──────┴──────┘
  KC_NO , KC_F7 , KC_F8 , KC_F9 , KC_F12 ,     KC_NO , KC_NO   , KC_NO   , MEH(KC_NO) , HYPR(KC_NO),
  KC_NO , KC_F4 , KC_F5 , KC_F6 , KC_F11 ,     KC_NO , KC_RSFT , KC_RCTL , KC_LALT    , KC_RGUI    ,
  KC_NO , KC_F1 , KC_F2 , KC_F3 , KC_F10 ,     KC_NO , KC_NO   , KC_NO   , KC_NO      , KC_NO      ,
                  KC_NO , KC_NO , KC_NO  ,     KC_NO , KC_NO   , KC_NO
),

[LY_MED] = LAYOUT_split_3x5_3(
//    ┌────┬──────┬──────┬──────┬────────┐   ┌────┬─────────┬─────────┬─────────┬────┐
//    │ no │ vold │ mute │ volu │   no   │   │ no │ RGB_HUD │ RGB_TOG │ RGB_HUI │ no │
//    ├────┼──────┼──────┼──────┼────────┤   ├────┼─────────┼─────────┼─────────┼────┤
//    │ no │ mprv │ mply │ mnxt │ MEH(k) │   │ no │ LGUI(-) │ LGUI(0) │ LGUI(=) │ no │
//    ├────┼──────┼──────┼──────┼────────┤   ├────┼─────────┼─────────┼─────────┼────┤
//    │ no │  no  │  no  │  no  │   no   │   │ no │ DT_DOWN │ DT_PRNT │  DT_UP  │ no │
//    └────┴──────┼──────┼──────┼────────┤   ├────┼─────────┼─────────┼─────────┴────┘
//                │  no  │  no  │   no   │   │ no │   no    │   no    │
//                └──────┴──────┴────────┘   └────┴─────────┴─────────┘
  KC_NO , KC_VOLD , KC_MUTE , KC_VOLU , KC_NO     ,     KC_NO , RGB_HUD       , RGB_TOG    , RGB_HUI      , KC_NO,
  KC_NO , KC_MPRV , KC_MPLY , KC_MNXT , MEH(KC_K) ,     KC_NO , LGUI(KC_MINS) , LGUI(KC_0) , LGUI(KC_EQL) , KC_NO,
  KC_NO , KC_NO   , KC_NO   , KC_NO   , KC_NO     ,     KC_NO , DT_DOWN       , DT_PRNT    , DT_UP        , KC_NO,
                    KC_NO   , KC_NO   , KC_NO     ,     KC_NO , KC_NO         , KC_NO
)
};
// clang-format on

// COMBO ================================================================================
const uint16_t PROGMEM togg_layer_ext_combo[] = {LT(LY_EXT, KC_SPC), LT(LY_MED, KC_BSPC), COMBO_END};
const uint16_t PROGMEM togg_layer_sym_combo[] = {LT(LY_SYM, KC_ESC), LT(LY_SYM, KC_ENT), COMBO_END};
const uint16_t PROGMEM togg_caps_word_combo[] = {LSFT_T(KC_V), RSFT_T(KC_M), COMBO_END};

combo_t key_combos[] = {
    COMBO(togg_layer_ext_combo, TO(LY_EXT)),
    COMBO(togg_layer_sym_combo, TO(LY_SYM)),
    COMBO(togg_caps_word_combo, CW_TOGG),
};

// SEND STRING ==========================================================================
bool process_record_user(uint16_t keycode, keyrecord_t *record) {
    switch (keycode) {
        case SS_TILD_SLSH:
            if (record->event.pressed) {
                SEND_STRING("~/");
            } else {
                // when keycode is released
            }
            break;
    }

    return true;
}

// TAP DANCE ============================================================================
enum tab_dance_events {
    //
    SINGLE_TAP = 1,
    SINGLE_HOLD,
    DOUBLE_TAP,
    DOUBLE_HOLD,
    TAP_HOLD,
    MORE_TAPS
};

uint8_t dance_step(tap_dance_state_t *state) {
    if (state->count == 1) {
        if (state->interrupted || !state->pressed)
            return SINGLE_TAP;
        else
            return SINGLE_HOLD;
    } else if (state->count == 2) {
        if (state->interrupted && state->pressed)
            return TAP_HOLD;
        else if (!state->interrupted && state->pressed)
            return DOUBLE_HOLD;
        else
            return DOUBLE_TAP;
    }
    return MORE_TAPS;
}

void custom_handle_tap_dance(tap_dance_state_t *state, uint16_t tap_single, uint16_t hold) {
    switch (dance_step(state)) {
        case SINGLE_TAP:
            register_code16(tap_single);
            break;
        case SINGLE_HOLD:
            register_code16(hold);
            break;
        case DOUBLE_TAP:
            register_code16(tap_single);
            register_code16(tap_single);
            break;
        default:
            break;
    }
}

void custom_reset_tap_dance(tap_dance_state_t *state, uint16_t tap_single, uint16_t hold) {
    switch (dance_step(state)) {
        case SINGLE_TAP:
        case DOUBLE_TAP:
            unregister_code16(tap_single);
            break;
        case SINGLE_HOLD:
        case DOUBLE_HOLD:
            unregister_code16(hold);
            break;
        default:
            break;
    }
}

void on_TD_EXT_GUI_A(tap_dance_state_t *state, void *user_data) {
    custom_handle_tap_dance(state, LGUI(KC_A), KC_LEFT_GUI);
}

void TD_EXT_GUI_A_reset(tap_dance_state_t *state, void *user_data) {
    custom_reset_tap_dance(state, LGUI(KC_A), KC_LEFT_GUI);
}

void on_TD_EXT_GUI_S(tap_dance_state_t *state, void *user_data) {
    custom_handle_tap_dance(state, LGUI(KC_S), KC_LEFT_ALT);
}

void TD_EXT_GUI_S_reset(tap_dance_state_t *state, void *user_data) {
    custom_reset_tap_dance(state, LGUI(KC_S), KC_LEFT_ALT);
}

void on_TD_EXT_GUI_D(tap_dance_state_t *state, void *user_data) {
    custom_handle_tap_dance(state, LGUI(KC_D), KC_LEFT_CTRL);
}

void TD_EXT_GUI_D_reset(tap_dance_state_t *state, void *user_data) {
    custom_reset_tap_dance(state, LGUI(KC_D), KC_LEFT_CTRL);
}

void on_TD_EXT_GUI_F(tap_dance_state_t *state, void *user_data) {
    custom_handle_tap_dance(state, LGUI(KC_F), KC_LEFT_SHIFT);
}

void TD_EXT_GUI_F_reset(tap_dance_state_t *state, void *user_data) {
    custom_reset_tap_dance(state, LGUI(KC_F), KC_LEFT_SHIFT);
}

// clang-format off
tap_dance_action_t tap_dance_actions[] = {
    [TD_EXT_GUI_A] = ACTION_TAP_DANCE_FN_ADVANCED(NULL, on_TD_EXT_GUI_A, TD_EXT_GUI_A_reset),
    [TD_EXT_GUI_S] = ACTION_TAP_DANCE_FN_ADVANCED(NULL, on_TD_EXT_GUI_S, TD_EXT_GUI_S_reset),
    [TD_EXT_GUI_D] = ACTION_TAP_DANCE_FN_ADVANCED(NULL, on_TD_EXT_GUI_D, TD_EXT_GUI_D_reset),
    [TD_EXT_GUI_F] = ACTION_TAP_DANCE_FN_ADVANCED(NULL, on_TD_EXT_GUI_F, TD_EXT_GUI_F_reset),
};
```

🤖:[ChatGPT4]
From the provided code snippet and your explanation, it seems the issue may indeed lie within the `custom_reset_tap_dance` function. First, let's take a step back and understand the underlying principles of tap dance functions in QMK.

Tap dance in QMK allows a key to trigger different actions depending on the number of taps or if the key is held down. The reset function of a tap dance feature is called when the tap dance action should terminate – either after the tap sequence is done or when the key is released after being held. Hence, the reset function should ensure that all used modifiers or keys are being released correctly.

One potential pitfall is the tap dance implementation checking for the `state->pressed` incorrectly within the reset function. However, seeing as the custom reset function doesn't do so, that doesn't seem to be the immediate issue.

Instead, based on what you have described, it seems the problem might be related to the tap dance not exiting the `SINGLE_HOLD` and `DOUBLE_HOLD` actions correctly. Since a held key by definition means you've pressed but not yet released it, it may get "stuck" if the release isn’t registered properly.

When you release the key, `custom_reset_tap_dance` is called, and it should unregister the modifier or keycodes accordingly based on the action previously registered. A possibility is the timing of the key state transition; the tap dance state might not process the `SINGLE_HOLD` end event as expected.

To provide a more targeted answer, I would need further clarification about the exact behavior and context in which the code fails to work properly. Based on the user-input pattern, the custom tap dance functions should trigger the correct key events.

Given our principle of zooming out and looking at the big picture, one can also consider the following debugging steps:

1. Check if the modifiers are stuck in software or hardware. Does the problem persist if you switch applications or reconnect the keyboard?
2. Use a QMK debugging tool like `hid_listen` to see what reports are being sent by the keyboard.
3. Ensure no other parts of the keymap or custom macros are registering keys that might conflict with the tap dance operation.

Since your suspicion is about the reset function, let's refine it a little more so that we include explicit codes for all cases:

```c
void custom_reset_tap_dance(tap_dance_state_t *state, uint16_t tap_single, uint16_t hold) {
    switch (dance_step(state)) {
        case SINGLE_TAP:
            unregister_code16(tap_single);
            break;
        case SINGLE_HOLD:
            unregister_code16(hold);
            layer_off(LY_EXT); // Turning off the layer if we want to ensure
            break;
        case DOUBLE_TAP:
            unregister_code16(tap_single);
            // Consider adding an inactive statement for DOUBLE_TAP if needed.
            break;
        case DOUBLE_HOLD:
            unregister_code16(hold);
            // Consider adding an inactive statement for DOUBLE_HOLD if needed.
            break;
        default:
            // A failsafe, de-register all possible codes.
            unregister_code16(hold);
            unregister_code16(tap_single);
            break;
    }
}
```

Please test the updated reset function and see whether this resolves the issue. If the problem persists, please provide additional details about the specific context in which it fails, any debug information, and we can delve deeper into troubleshooting.

🗨:
Why the `layer_off` This should be needed right? This seems off to me

🤖:[ChatGPT4]
I apologize; you are correct that the `layer_off(LY_EXT)` call is unnecessary and incorrect in this context. That line was mistakenly included as the Tap Dance functionality does not require you to turn any layer off specifically as part of the reset. Layers are managed separately and are unrelated to the tap-hold mechanics in the way you've described your setup.

Let's just focus on unregistering the proper keycodes:

The simplified and corrected `custom_reset_tap_dance` function should look like this:

```c
void custom_reset_tap_dance(tap_dance_state_t *state, uint16_t tap_single, uint16_t hold) {
    switch (dance_step(state)) {
        case SINGLE_TAP:
            unregister_code16(tap_single);
            break;
        case SINGLE_HOLD:
            unregister_code16(hold);
            break;
        case DOUBLE_TAP:
            unregister_code16(tap_single);
            // No additional unregistrations for DOUBLE_TAP since it triggers SINGLE_TAP events
            break;
        case DOUBLE_HOLD:
            unregister_code16(hold);
            // No additional unregistrations for DOUBLE_HOLD since it triggers SINGLE_HOLD events
            break;
        default:
            // Failsafe, unregister all possible keycodes.
            unregister_code16(tap_single);
            unregister_code16(hold);
            break;
    }
}
```

This function makes sure that once a Tap Dance event sequence has finished or the key is released, the corresponding keycodes that were pressed (tapped or held) are released (unregistered).

This adjustment should fix the “stuck” modifier keys issue, assuming your `custom_handle_tap_dance` function registers them correctly upon taps/holds.

If the keys still appear to be stuck in their modifier state after releasing them, then debugging could include:

1. Confirm by console logs or LED indicators that the reset function is called. Use QMK's `uprintf` function to print debug messages over serial to the QMK Toolbox or another listening program.
2. Ensure no other parts of your keymap or QMK code override the tap dance behavior.

Once again, I apologize for any confusion, and if this fix does not resolve the issue, please provide more details about the fault state or further problems encountered, and we can explore alternative solutions.

🗨:
So i tried it, but the command still gets stuck.
this is what i currently have:

```c

void custom_reset_tap_dance(tap_dance_state_t *state, uint16_t tap_single, uint16_t hold) {
    switch (dance_step(state)) {
        case SINGLE_TAP:
            unregister_code16(tap_single);
            break;
        case SINGLE_HOLD:
            unregister_code16(hold);
            break;
        case DOUBLE_TAP:
            unregister_code16(tap_single);
            // No additional unregistrations for DOUBLE_TAP since it triggers SINGLE_TAP events
            break;
        case DOUBLE_HOLD:
            unregister_code16(hold);
            // No additional unregistrations for DOUBLE_HOLD since it triggers SINGLE_HOLD events
            break;
        default:
            // Failsafe, unregister all possible keycodes.
            unregister_code16(tap_single);
            unregister_code16(hold);
            break;
    }
}
```

and this is the log of a short test via karabiner eventviewer:

```
[
  {
    "type": "down",
    "name": {"key_code":"left_command"},
    "usagePage": "7 (0x0007)",
    "usage": "227 (0x00e3)",
    "misc": "flags left_command"
  },
  {
    "type": "down",
    "name": {"key_code":"a"},
    "usagePage": "7 (0x0007)",
    "usage": "4 (0x0004)",
    "misc": "flags left_command"
  },
  {
    "type": "up",
    "name": {"key_code":"a"},
    "usagePage": "7 (0x0007)",
    "usage": "4 (0x0004)",
    "misc": "flags left_command"
  },
  {
    "type": "up",
    "name": {"key_code":"left_command"},
    "usagePage": "7 (0x0007)",
    "usage": "227 (0x00e3)",
    "misc": ""
  },
  {
    "type": "down",
    "name": {"key_code":"left_command"},
    "usagePage": "7 (0x0007)",
    "usage": "227 (0x00e3)",
    "misc": "flags left_command"
  },
  {
    "type": "down",
    "name": {"key_code":"j"},
    "usagePage": "7 (0x0007)",
    "usage": "13 (0x000d)",
    "misc": "flags left_command"
  },
  {
    "type": "up",
    "name": {"key_code":"j"},
    "usagePage": "7 (0x0007)",
    "usage": "13 (0x000d)",
    "misc": "flags left_command"
  },
  {
    "type": "down",
    "name": {"key_code":"j"},
    "usagePage": "7 (0x0007)",
    "usage": "13 (0x000d)",
    "misc": "flags left_command"
  },
  {
    "type": "up",
    "name": {"key_code":"j"},
    "usagePage": "7 (0x0007)",
    "usage": "13 (0x000d)",
    "misc": "flags left_command"
  },
  {
    "type": "down",
    "name": {"key_code":"j"},
    "usagePage": "7 (0x0007)",
    "usage": "13 (0x000d)",
    "misc": "flags left_command"
  },
  {
    "type": "up",
    "name": {"key_code":"j"},
    "usagePage": "7 (0x0007)",
    "usage": "13 (0x000d)",
    "misc": "flags left_command"
  },
  {
    "type": "down",
    "name": {"key_code":"j"},
    "usagePage": "7 (0x0007)",
    "usage": "13 (0x000d)",
    "misc": "flags left_command"
  },
  {
    "type": "up",
    "name": {"key_code":"j"},
    "usagePage": "7 (0x0007)",
    "usage": "13 (0x000d)",
    "misc": "flags left_command"
  },
  {
    "type": "down",
    "name": {"key_code":"k"},
    "usagePage": "7 (0x0007)",
    "usage": "14 (0x000e)",
    "misc": "flags left_command"
  },
  {
    "type": "up",
    "name": {"key_code":"k"},
    "usagePage": "7 (0x0007)",
    "usage": "14 (0x000e)",
    "misc": "flags left_command"
  },
  {
    "type": "down",
    "name": {"key_code":"j"},
    "usagePage": "7 (0x0007)",
    "usage": "13 (0x000d)",
    "misc": "flags left_command"
  },
  {
    "type": "up",
    "name": {"key_code":"j"},
    "usagePage": "7 (0x0007)",
    "usage": "13 (0x000d)",
    "misc": "flags left_command"
  },
  {
    "type": "down",
    "name": {"pointing_button":"button1"},
    "usagePage": "9 (0x0009)",
    "usage": "1 (0x0001)",
    "misc": ""
  }
]
```

🤖:[ChatGPT4]
Thank you for providing the log from Karabiner EventViewer. The log suggests that the `left_command` (i.e., `LGUI` in QMK) keycode is sent down and up correctly for the 'a' key, which indicates that the tap action for `TD_EXT_GUI_A` (tap of `EXT+a`) is working as expected.

However, there seems to be an issue where other keys pressed afterward are still registering with the `left_command` modifier (e.g., the 'j' and 'k' keys). This behavior suggests that despite the 'a' key being released, the `left_command` continues to act as though it is being held down.

This issue could be due to the tap dance state not transitioning correctly into the `SINGLE_HOLD` state and back. We should ensure that when the key is released, the correct modifier key event is being sent to unregister it.

Normally, QMK will register and unregister keys and modifiers when they are pressed and released. However, tap dance complicates this by potentially introducing a delay or different behavior based on input patterns.

If you are still experiencing the issue even after ensuring your `custom_reset_tap_dance` function accurately unregisters the taps and holds, you might want to try adding direct calls to `unregister_mods` and `clear_mods` to ensure all modifiers are correctly reset.

Try adding these calls to the `custom_reset_tap_dance` function as follows:

```c
void custom_reset_tap_dance(tap_dance_state_t *state, uint16_t tap_single, uint16_t hold) {
    switch (dance_step(state)) {
        case SINGLE_TAP:
            unregister_code16(tap_single);
            break;
        case SINGLE_HOLD:
            unregister_code16(hold);
            clear_mods(); // Clear all mods to be safe.
            break;
        case DOUBLE_TAP:
            unregister_code16(tap_single);
            break;
        case DOUBLE_HOLD:
            unregister_code16(hold);
            break;
        default:
            unregister_code16(tap_single);
            unregister_code16(hold);
            break;
    }
}
```

This modification ensures that all modifiers are released when the tap dance sequence ends, correcting any potential "sticking" issues.

It might also be the case that some other part of the firmware or a hardware issue could be conflicting. For example, ghosting or key chatter can sometimes create similar issues. If you've only experienced this problem with specific keys or in specific software, that could point to an external factor playing a role.

If these changes still do not resolve your problem, I would then suggest a few additional debugging strategies:

1. Reduce the complexity of your `keymap.c` down to a minimal example that solely handles the tap dance function in question.

2. Test this minimal configuration to confirm whether the problem persists without the other potential confounding factors.

3. If using a custom keyboard, check any diode-related hardware issues that may be incorrect or causing ghosting/stuck keys.

4. Reach out to the QMK community or forums with your details. Other users or even the developers may have insights into specific issues with certain boards or configurations.

If you're confident there is an issue specifically with QMK's handling of tap dance, and the problem isn't resolved at this level, it might be necessary to report this as a bug to the QMK Github repository.

🗨:
Okay i will try.

🤖:[ChatGPT4]
Great! Take your time testing the suggested changes, and if you run into any issues, try to examine them calmly and methodically, breaking down the testing into steps to isolate the problem.

Remember the process for troubleshooting effectively:

1. **Isolate**: Reduce the complexity and try to focus on the specific area where the problem occurs. If necessary, revert to a simpler configuration that only has the tap dance logic and see if the issue persists.

2. **Identify**: Look for any patterns or specific conditions that trigger the problem. Is it associated with a particular layer? Does it only occur after certain key sequences?

3. **Investigate**: Use QMK tools for live debugging. Make use of `uprintf` in the console or debug LEDs to get feedback on the internal state of the tap dance actions.

4. **Iterate**: Apply one change at a time and test it thoroughly. This method prevents new issues from being introduced and makes it easier to pinpoint the cause.

5. **Reach out**: If you're still stuck, don't hesitate to engage with the QMK community or other developers who might have encountered similar issues.

6. **Documentation**: Remember to document the changes you make and the results from testing. This can be crucial if you need to retrace your steps or explain the issue to others for help.

If the problem is resolved, consider contributing back to the community by sharing your experience and solution where it might help others. Good luck, and don't hesitate to ask for further assistance if needed!

🗨:
I tried this but it seems the hold action never seems to go "up" anymore, although i released it. maybe the problem is somewhere else (maybe dance_step?)

this is what i currently have:

```c
/*
Copyright 2019 @foostan
Copyright 2020 Drashna Jaelre <@drashna>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include QMK_KEYBOARD_H

enum layers {
    //
    LY_BAS,
    LY_EXT,
    LY_SYM,
    LY_NUM,
    LY_FUN,
    LY_MED
};

enum custom_keycodes {
    SS_TILD_SLSH = SAFE_RANGE,
};

enum tap_dance_codes {
    //
    TD_EXT_GUI_A,
    TD_EXT_GUI_S,
    TD_EXT_GUI_D,
    TD_EXT_GUI_F
};

// KEYMAP ===============================================================================
// clang-format off
const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = {
[LY_BAS] = LAYOUT_split_3x5_3(
//    ┌───────────┬───────────┬────────────────┬─────────────────┬─────────────────┐   ┌──────────────────┬─────────────────┬────────────────┬───────────┬───────────┐
//    │     q     │     w     │       e        │        r        │        t        │   │        y         │        u        │       i        │     o     │     p     │
//    ├───────────┼───────────┼────────────────┼─────────────────┼─────────────────┤   ├──────────────────┼─────────────────┼────────────────┼───────────┼───────────┤
//    │     a     │     s     │       d        │        f        │        g        │   │        h         │        j        │       k        │     l     │     ;     │
//    ├───────────┼───────────┼────────────────┼─────────────────┼─────────────────┤   ├──────────────────┼─────────────────┼────────────────┼───────────┼───────────┤
//    │ LGUI_T(z) │ LALT_T(x) │   LCTL_T(c)    │    LSFT_T(v)    │        b        │   │        n         │    RSFT_T(m)    │   RCTL_T(,)    │ LALT_T(.) │ RGUI_T(/) │
//    └───────────┴───────────┼────────────────┼─────────────────┼─────────────────┤   ├──────────────────┼─────────────────┼────────────────┼───────────┴───────────┘
//                            │ LT(LY_NUM, no) │ LT(LY_SYM, esc) │ LT(LY_EXT, spc) │   │ LT(LY_MED, bspc) │ LT(LY_SYM, ent) │ LT(LY_FUN, no) │
//                            └────────────────┴─────────────────┴─────────────────┘   └──────────────────┴─────────────────┴────────────────┘
  KC_Q         , KC_W         , KC_E              , KC_R               , KC_T               ,     KC_Y                , KC_U               , KC_I              , KC_O           , KC_P           ,
  KC_A         , KC_S         , KC_D              , KC_F               , KC_G               ,     KC_H                , KC_J               , KC_K              , KC_L           , KC_SCLN        ,
  LGUI_T(KC_Z) , LALT_T(KC_X) , LCTL_T(KC_C)      , LSFT_T(KC_V)       , KC_B               ,     KC_N                , RSFT_T(KC_M)       , RCTL_T(KC_COMM)   , LALT_T(KC_DOT) , RGUI_T(KC_SLSH),
                                LT(LY_NUM, KC_NO) , LT(LY_SYM, KC_ESC) , LT(LY_EXT, KC_SPC) ,     LT(LY_MED, KC_BSPC) , LT(LY_SYM, KC_ENT) , LT(LY_FUN, KC_NO)
),

[LY_EXT] = LAYOUT_split_3x5_3(
//    ┌──────────────────┬──────────────────┬──────────────────┬──────────────────┬────────────┐   ┌──────┬────────┬───────────┬───────────┬────┐
//    │     LGUI(q)      │     LGUI(w)      │     LGUI(e)      │     LGUI(r)      │  LGUI(t)   │   │  no  │ LAG(i) │  LGUI(`)  │ LGUI(tab) │ no │
//    ├──────────────────┼──────────────────┼──────────────────┼──────────────────┼────────────┤   ├──────┼────────┼───────────┼───────────┼────┤
//    │ TD(TD_EXT_GUI_A) │ TD(TD_EXT_GUI_S) │ TD(TD_EXT_GUI_D) │ TD(TD_EXT_GUI_F) │  LGUI(g)   │   │ left │  down  │    up     │   rght    │ no │
//    ├──────────────────┼──────────────────┼──────────────────┼──────────────────┼────────────┤   ├──────┼────────┼───────────┼───────────┼────┤
//    │     LGUI(z)      │     LGUI(x)      │     LGUI(c)      │     LGUI(v)      │  LGUI(b)   │   │  no  │   no   │ LSFT(tab) │    tab    │ no │
//    └──────────────────┴──────────────────┼──────────────────┼──────────────────┼────────────┤   ├──────┼────────┼───────────┼───────────┴────┘
//                                          │        no        │        no        │ TO(LY_BAS) │   │ del  │   no   │    no     │
//                                          └──────────────────┴──────────────────┴────────────┘   └──────┴────────┴───────────┘
  LGUI(KC_Q)       , LGUI(KC_W)       , LGUI(KC_E)       , LGUI(KC_R)       , LGUI(KC_T) ,     KC_NO   , LAG(KC_I) , LGUI(KC_GRV) , LGUI(KC_TAB) , KC_NO,
  TD(TD_EXT_GUI_A) , TD(TD_EXT_GUI_S) , TD(TD_EXT_GUI_D) , TD(TD_EXT_GUI_F) , LGUI(KC_G) ,     KC_LEFT , KC_DOWN   , KC_UP        , KC_RGHT      , KC_NO,
  LGUI(KC_Z)       , LGUI(KC_X)       , LGUI(KC_C)       , LGUI(KC_V)       , LGUI(KC_B) ,     KC_NO   , KC_NO     , LSFT(KC_TAB) , KC_TAB       , KC_NO,
                                        KC_NO            , KC_NO            , TO(LY_BAS) ,     KC_DEL  , KC_NO     , KC_NO
),

[LY_SYM] = LAYOUT_split_3x5_3(
//    ┌───┬───┬─────┬────────────┬─────┐   ┌─────┬────────────┬─────┬───┬───┐
//    │ ^ │ + │  #  │     %      │  $  │   │  <  │     {      │  "  │ } │ > │
//    ├───┼───┼─────┼────────────┼─────┤   ├─────┼────────────┼─────┼───┼───┤
//    │ ! │ - │  &  │     ?      │  |  │   │  =  │     [      │  '  │ ] │ : │
//    ├───┼───┼─────┼────────────┼─────┤   ├─────┼────────────┼─────┼───┼───┤
//    │ ~ │ _ │  *  │     @      │ ~/  │   │  \  │     (      │  `  │ ) │ / │
//    └───┴───┼─────┼────────────┼─────┤   ├─────┼────────────┼─────┼───┴───┘
//            │     │ TO(LY_BAS) │     │   │     │ TO(LY_BAS) │     │
//            └─────┴────────────┴─────┘   └─────┴────────────┴─────┘
  KC_CIRC , KC_PLUS , KC_HASH , KC_PERC    , KC_DLR       ,     KC_LT   , KC_LCBR    , KC_DQUO , KC_RCBR , KC_GT  ,
  KC_EXLM , KC_MINS , KC_AMPR , KC_QUES    , KC_PIPE      ,     KC_EQL  , KC_LBRC    , KC_QUOT , KC_RBRC , KC_COLN,
  KC_TILD , KC_UNDS , KC_ASTR , KC_AT      , SS_TILD_SLSH ,     KC_BSLS , KC_LPRN    , KC_GRV  , KC_RPRN , KC_SLSH,
                      KC_TRNS , TO(LY_BAS) , KC_TRNS      ,     KC_TRNS , TO(LY_BAS) , KC_TRNS
),

[LY_NUM] = LAYOUT_split_3x5_3(
//    ┌──────────┬─────────┬──────┬──────┬─────┐   ┌──────┬──────┬──────┬──────┬──────┐
//    │ HYPR(no) │ MEH(no) │  no  │  no  │ no  │   │ kp_+ │ kp_7 │ kp_8 │ kp_9 │ kp_* │
//    ├──────────┼─────────┼──────┼──────┼─────┤   ├──────┼──────┼──────┼──────┼──────┤
//    │   lgui   │  lalt   │ lctl │ lsft │ no  │   │ kp_= │ kp_4 │ kp_5 │ kp_6 │  :   │
//    ├──────────┼─────────┼──────┼──────┼─────┤   ├──────┼──────┼──────┼──────┼──────┤
//    │    no    │   no    │  no  │  no  │ no  │   │ kp_- │ kp_1 │ kp_2 │ kp_3 │ kp_/ │
//    └──────────┴─────────┼──────┼──────┼─────┤   ├──────┼──────┼──────┼──────┴──────┘
//                         │      │      │     │   │      │ kp_0 │      │
//                         └──────┴──────┴─────┘   └──────┴──────┴──────┘
  HYPR(KC_NO) , MEH(KC_NO) , KC_NO   , KC_NO   , KC_NO   ,     KC_PPLS , KC_P7 , KC_P8   , KC_P9 , KC_PAST,
  KC_LGUI     , KC_LALT    , KC_LCTL , KC_LSFT , KC_NO   ,     KC_PEQL , KC_P4 , KC_P5   , KC_P6 , KC_COLN,
  KC_NO       , KC_NO      , KC_NO   , KC_NO   , KC_NO   ,     KC_PMNS , KC_P1 , KC_P2   , KC_P3 , KC_PSLS,
                             KC_TRNS , KC_TRNS , KC_TRNS ,     KC_TRNS , KC_P0 , KC_TRNS
),

[LY_FUN] = LAYOUT_split_3x5_3(
//    ┌────┬────┬────┬────┬─────┐   ┌────┬──────┬──────┬─────────┬──────────┐
//    │ no │ f7 │ f8 │ f9 │ f12 │   │ no │  no  │  no  │ MEH(no) │ HYPR(no) │
//    ├────┼────┼────┼────┼─────┤   ├────┼──────┼──────┼─────────┼──────────┤
//    │ no │ f4 │ f5 │ f6 │ f11 │   │ no │ rsft │ rctl │  lalt   │   rgui   │
//    ├────┼────┼────┼────┼─────┤   ├────┼──────┼──────┼─────────┼──────────┤
//    │ no │ f1 │ f2 │ f3 │ f10 │   │ no │  no  │  no  │   no    │    no    │
//    └────┴────┼────┼────┼─────┤   ├────┼──────┼──────┼─────────┴──────────┘
//              │ no │ no │ no  │   │ no │  no  │  no  │
//              └────┴────┴─────┘   └────┴──────┴──────┘
  KC_NO , KC_F7 , KC_F8 , KC_F9 , KC_F12 ,     KC_NO , KC_NO   , KC_NO   , MEH(KC_NO) , HYPR(KC_NO),
  KC_NO , KC_F4 , KC_F5 , KC_F6 , KC_F11 ,     KC_NO , KC_RSFT , KC_RCTL , KC_LALT    , KC_RGUI    ,
  KC_NO , KC_F1 , KC_F2 , KC_F3 , KC_F10 ,     KC_NO , KC_NO   , KC_NO   , KC_NO      , KC_NO      ,
                  KC_NO , KC_NO , KC_NO  ,     KC_NO , KC_NO   , KC_NO
),

[LY_MED] = LAYOUT_split_3x5_3(
//    ┌────┬──────┬──────┬──────┬────────┐   ┌────┬─────────┬─────────┬─────────┬────┐
//    │ no │ vold │ mute │ volu │   no   │   │ no │ RGB_HUD │ RGB_TOG │ RGB_HUI │ no │
//    ├────┼──────┼──────┼──────┼────────┤   ├────┼─────────┼─────────┼─────────┼────┤
//    │ no │ mprv │ mply │ mnxt │ MEH(k) │   │ no │ LGUI(-) │ LGUI(0) │ LGUI(=) │ no │
//    ├────┼──────┼──────┼──────┼────────┤   ├────┼─────────┼─────────┼─────────┼────┤
//    │ no │  no  │  no  │  no  │   no   │   │ no │ DT_DOWN │ DT_PRNT │  DT_UP  │ no │
//    └────┴──────┼──────┼──────┼────────┤   ├────┼─────────┼─────────┼─────────┴────┘
//                │  no  │  no  │   no   │   │ no │   no    │   no    │
//                └──────┴──────┴────────┘   └────┴─────────┴─────────┘
  KC_NO , KC_VOLD , KC_MUTE , KC_VOLU , KC_NO     ,     KC_NO , RGB_HUD       , RGB_TOG    , RGB_HUI      , KC_NO,
  KC_NO , KC_MPRV , KC_MPLY , KC_MNXT , MEH(KC_K) ,     KC_NO , LGUI(KC_MINS) , LGUI(KC_0) , LGUI(KC_EQL) , KC_NO,
  KC_NO , KC_NO   , KC_NO   , KC_NO   , KC_NO     ,     KC_NO , DT_DOWN       , DT_PRNT    , DT_UP        , KC_NO,
                    KC_NO   , KC_NO   , KC_NO     ,     KC_NO , KC_NO         , KC_NO
)
};
// clang-format on

// COMBO ================================================================================
const uint16_t PROGMEM togg_layer_ext_combo[] = {LT(LY_EXT, KC_SPC), LT(LY_MED, KC_BSPC), COMBO_END};
const uint16_t PROGMEM togg_layer_sym_combo[] = {LT(LY_SYM, KC_ESC), LT(LY_SYM, KC_ENT), COMBO_END};
const uint16_t PROGMEM togg_caps_word_combo[] = {LSFT_T(KC_V), RSFT_T(KC_M), COMBO_END};

combo_t key_combos[] = {
    COMBO(togg_layer_ext_combo, TO(LY_EXT)),
    COMBO(togg_layer_sym_combo, TO(LY_SYM)),
    COMBO(togg_caps_word_combo, CW_TOGG),
};

// SEND STRING ==========================================================================
bool process_record_user(uint16_t keycode, keyrecord_t *record) {
    switch (keycode) {
        case SS_TILD_SLSH:
            if (record->event.pressed) {
                SEND_STRING("~/");
            } else {
                // when keycode is released
            }
            break;
    }

    return true;
}

// TAP DANCE ============================================================================
enum tab_dance_events {
    //
    SINGLE_TAP = 1,
    SINGLE_HOLD,
    DOUBLE_TAP,
    DOUBLE_HOLD,
    TAP_HOLD,
    MORE_TAPS
};

uint8_t dance_step(tap_dance_state_t *state) {
    if (state->count == 1) {
        if (state->interrupted || !state->pressed)
            return SINGLE_TAP;
        else
            return SINGLE_HOLD;
    } else if (state->count == 2) {
        if (state->interrupted && state->pressed)
            return TAP_HOLD;
        else if (!state->interrupted && state->pressed)
            return DOUBLE_HOLD;
        else
            return DOUBLE_TAP;
    }
    return MORE_TAPS;
}

void custom_handle_tap_dance(tap_dance_state_t *state, uint16_t tap_single, uint16_t hold) {
    switch (dance_step(state)) {
        case SINGLE_TAP:
            register_code16(tap_single);
            break;
        case SINGLE_HOLD:
            register_code16(hold);
            break;
        case DOUBLE_TAP:
            register_code16(tap_single);
            register_code16(tap_single);
            break;
        default:
            break;
    }
}

void custom_reset_tap_dance(tap_dance_state_t *state, uint16_t tap_single, uint16_t hold) {
    switch (dance_step(state)) {
        case SINGLE_TAP:
            unregister_code16(tap_single);
            break;
        case SINGLE_HOLD:
            unregister_code16(hold);
            clear_mods(); // Clear all mods to be safe.
            break;
        case DOUBLE_TAP:
            unregister_code16(tap_single);
            break;
        case DOUBLE_HOLD:
            unregister_code16(hold);
            clear_mods(); // Clear all mods to be safe.
            break;
        default:
            unregister_code16(tap_single);
            unregister_code16(hold);
            break;
    }
}

void on_TD_EXT_GUI_A(tap_dance_state_t *state, void *user_data) {
    custom_handle_tap_dance(state, LGUI(KC_A), KC_LEFT_GUI);
}

void TD_EXT_GUI_A_reset(tap_dance_state_t *state, void *user_data) {
    custom_reset_tap_dance(state, LGUI(KC_A), KC_LEFT_GUI);
}

void on_TD_EXT_GUI_S(tap_dance_state_t *state, void *user_data) {
    custom_handle_tap_dance(state, LGUI(KC_S), KC_LEFT_ALT);
}

void TD_EXT_GUI_S_reset(tap_dance_state_t *state, void *user_data) {
    custom_reset_tap_dance(state, LGUI(KC_S), KC_LEFT_ALT);
}

void on_TD_EXT_GUI_D(tap_dance_state_t *state, void *user_data) {
    custom_handle_tap_dance(state, LGUI(KC_D), KC_LEFT_CTRL);
}

void TD_EXT_GUI_D_reset(tap_dance_state_t *state, void *user_data) {
    custom_reset_tap_dance(state, LGUI(KC_D), KC_LEFT_CTRL);
}

void on_TD_EXT_GUI_F(tap_dance_state_t *state, void *user_data) {
    custom_handle_tap_dance(state, LGUI(KC_F), KC_LEFT_SHIFT);
}

void TD_EXT_GUI_F_reset(tap_dance_state_t *state, void *user_data) {
    custom_reset_tap_dance(state, LGUI(KC_F), KC_LEFT_SHIFT);
}

// clang-format off
tap_dance_action_t tap_dance_actions[] = {
    [TD_EXT_GUI_A] = ACTION_TAP_DANCE_FN_ADVANCED(NULL, on_TD_EXT_GUI_A, TD_EXT_GUI_A_reset),
    [TD_EXT_GUI_S] = ACTION_TAP_DANCE_FN_ADVANCED(NULL, on_TD_EXT_GUI_S, TD_EXT_GUI_S_reset),
    [TD_EXT_GUI_D] = ACTION_TAP_DANCE_FN_ADVANCED(NULL, on_TD_EXT_GUI_D, TD_EXT_GUI_D_reset),
    [TD_EXT_GUI_F] = ACTION_TAP_DANCE_FN_ADVANCED(NULL, on_TD_EXT_GUI_F, TD_EXT_GUI_F_reset),
};
```

this is the output of my lasttest with karabiner eventviewer:

```
[
  {
    "type": "down",
    "name": {"key_code":"left_command"},
    "usagePage": "7 (0x0007)",
    "usage": "227 (0x00e3)",
    "misc": "flags left_command"
  },
  {
    "type": "down",
    "name": {"key_code":"a"},
    "usagePage": "7 (0x0007)",
    "usage": "4 (0x0004)",
    "misc": "flags left_command"
  },
  {
    "type": "up",
    "name": {"key_code":"a"},
    "usagePage": "7 (0x0007)",
    "usage": "4 (0x0004)",
    "misc": "flags left_command"
  },
  {
    "type": "up",
    "name": {"key_code":"left_command"},
    "usagePage": "7 (0x0007)",
    "usage": "227 (0x00e3)",
    "misc": ""
  },
  {
    "type": "down",
    "name": {"key_code":"left_command"},
    "usagePage": "7 (0x0007)",
    "usage": "227 (0x00e3)",
    "misc": "flags left_command"
  },
  {
    "type": "down",
    "name": {"key_code":"a"},
    "usagePage": "7 (0x0007)",
    "usage": "4 (0x0004)",
    "misc": "flags left_command"
  },
  {
    "type": "up",
    "name": {"key_code":"a"},
    "usagePage": "7 (0x0007)",
    "usage": "4 (0x0004)",
    "misc": "flags left_command"
  },
  {
    "type": "down",
    "name": {"key_code":"a"},
    "usagePage": "7 (0x0007)",
    "usage": "4 (0x0004)",
    "misc": "flags left_command"
  },
  {
    "type": "up",
    "name": {"key_code":"a"},
    "usagePage": "7 (0x0007)",
    "usage": "4 (0x0004)",
    "misc": "flags left_command"
  },
  {
    "type": "down",
    "name": {"key_code":"a"},
    "usagePage": "7 (0x0007)",
    "usage": "4 (0x0004)",
    "misc": "flags left_command"
  },
  {
    "type": "up",
    "name": {"key_code":"a"},
    "usagePage": "7 (0x0007)",
    "usage": "4 (0x0004)",
    "misc": "flags left_command"
  },
  {
    "type": "down",
    "name": {"key_code":"a"},
    "usagePage": "7 (0x0007)",
    "usage": "4 (0x0004)",
    "misc": "flags left_command"
  },
  {
    "type": "up",
    "name": {"key_code":"a"},
    "usagePage": "7 (0x0007)",
    "usage": "4 (0x0004)",
    "misc": "flags left_command"
  },
  {
    "type": "down",
    "name": {"pointing_button":"button1"},
    "usagePage": "9 (0x0009)",
    "usage": "1 (0x0001)",
    "misc": ""
  },
  {
    "type": "up",
    "name": {"pointing_button":"button1"},
    "usagePage": "9 (0x0009)",
    "usage": "1 (0x0001)",
    "misc": ""
  }
]
```

🤖:[ChatGPT4]
Analyzing the provided code and logs, it doesn't show the release of the `left_command` after holding, which was expected to be implemented in `custom_reset_tap_dance` with `unregister_code16(hold)` followed by `clear_mods()`. However, `clear_mods()` only unsets the mod status but doesn't send the necessary USB reports to the computer to update its internal mod status; `clear_mods()` is useful mostly in the context of keys that change layers and modifiers internally; in your case, you want to ensure the computer receives the release.

Let's tackle this step-by-step from first principles:

1. **Big Picture**: Your goal is to have keys on the `LY_EXT` layer perform two functions based on tap (quick press and release) and hold (press and not release quickly) actions.

2. **Specifics**:
   - Tap: triggers LGUI + KC_A/S/D/F
   - Hold: switches to a certain modifier (LGUI / LALT / LCTL / LSFT)

To aid with debugging, you should focus on a single tap dance key to limit the variables at play, narrowing down the behavior to a single function at a time.

Let's clarify the `custom_handle_tap_dance` and `custom_reset_tap_dance` functions. Your strategy in `custom_handle_tap_dance` seems fine: on a single tap, send the modified key (`LGUI(KC_A)` for example), and on hold, register the holding mod (`LGUI` itself). For `custom_reset_tap_dance`, you unregister what you've registered.

The `unregister_code16(hold)` should be enough to tell QMK and, by extension, the OS that the key is released. The intricacies of how QMK processes this and communicates with the OS might involve some overlooked details that are causing the "stickiness."

If this does not work as intended, consider manual mod manipulation, but to start, clear up the broader `clear_mods` and introduce a targeted approach:

```c
void custom_reset_tap_dance(tap_dance_state_t *state, uint16_t tap_single, uint16_t hold) {
    switch (dance_step(state)) {
        case SINGLE_TAP:
            unregister_code16(tap_single);
            break;
        case SINGLE_HOLD:
            unregister_code16(hold);
            if(hold == KC_LGUI) {
                unregister_mods(MOD_BIT(KC_LGUI)); // Specifically handle GUI
            }
            // rinse and repeat for each modifier
            // else if...
            break;
        case DOUBLE_TAP:
            unregister_code16(tap_single);
            // handle double-tap case if necessary
            break;
        case DOUBLE_HOLD:
            unregister_code16(hold); // ONLY if double-tap can get stuck
            // handle double-hold case if necessary
            break;
        default:
            unregister_code16(tap_single);
            unregister_code16(hold);
            break;
    }
}
```

For `unregister_mods`, note that `MOD_BIT(KC_LGUI)` is used instead of `KC_LGUI`. This is necessary because the `unregister_mods` function takes a bitmask instead of a keycode. Collect each mod flag into a bitmask, and unregister all of them at once if needed.

Ensuring tap dances reset correctly is difficult because it involves timing, human factors (users vary in how they press and hold keys), and interaction with an operating system that has its mod-state logic; it might not correctly process the rapid-fire key events.

Please apply the above changes or similar adjustments. If issues persist, focusing on QMK's behavior before it gets to Karabiner or other software-based event loggers is recommended. This might require closer debugging with tools like `hid_listen` as mentioned before.

It might still be an issue with `dance_step` not working as intended, but if the reset logic doesn't even apply correctly, the problem will persist even if `dance_step` is returning the proper values.

Continue using an incremental approach, validating the behavior of each function as you go, and make sure no other part of your code or QMK changes the appointed behavior. If this isolated change doesn't solve the problem, then we can re-investigate `dance_step` further or take a deeper look at how QMK processes the tap dance actions on hold release.

🗨:
if the generic functions have conditions in them, .. then there is no purpose. please give me a full solution, with dedicated function for each tab dance and reset without the generic functions.

🤖:[ChatGPT4]
Certainly! Let's create dedicated tap dance functions for each key action without using the generic functions. This might be more verbose, but it will provide clarity over what exactly happens during each tap dance event and allow for any necessary customization without impacting other keys.

First, define the tap dance actions for each key. We will create separate functions for the tap (single-tap) and hold for each corresponding key (a, s, d, f) and then for their reset actions:

```c
void on_tap_dance_ext_gui_a_finished(qk_tap_dance_state_t *state, void *user_data) {
    if (state->count == 1) {
        // Single Tap: GUI + Key A
        register_code(KC_LGUI);
        register_code(KC_A);
        unregister_code(KC_A);
        unregister_code(KC_LGUI);
    } else {
        // Hold: Just GUI
        register_code(KC_LGUI);
    }
}

void on_tap_dance_ext_gui_a_reset(qk_tap_dance_state_t *state, void *user_data) {
    // Always unregister GUI when the key is released.
    unregister_code(KC_LGUI);
}

void on_tap_dance_ext_gui_s_finished(qk_tap_dance_state_t *state, void *user_data) {
    // Implement the finishing action for 's'
}

void on_tap_dance_ext_gui_s_reset(qk_tap_dance_state_t *state, void *user_data) {
    // Implement the reset action for 's'
}

// Repeat for d, f...

// tap_dance_actions
qk_tap_dance_action_t tap_dance_actions[] = {
    [TD_EXT_GUI_A] = ACTION_TAP_DANCE_FN_ADVANCED(NULL, on_tap_dance_ext_gui_a_finished, on_tap_dance_ext_gui_a_reset),
    // Other actions...
};
```

For the 's' key, repeat this pattern, replacing `KC_A` and `KC_LGUI` with `KC_S` and `KC_LALT` respectively, and similarly for 'd' and 'f' with their associated modifiers.

Here's the pattern repeated for 's' as an example:

```c
void on_tap_dance_ext_gui_s_finished(qk_tap_dance_state_t *state, void *user_data) {
    if (state->count == 1) {
        // Single Tap: GUI + Key S
        register_code(KC_LGUI);
        register_code(KC_S);
        unregister_code(KC_S);
        unregister_code(KC_LGUI);
    } else {
        // Hold: Just LALT
        register_code(KC_LALT);
    }
}

void on_tap_dance_ext_gui_s_reset(qk_tap_dance_state_t *state, void *user_data) {
    // Always unregister LALT when the key is released.
    unregister_code(KC_LALT);
}

qk_tap_dance_action_t tap_dance_actions[] = {
    // ... existing
    [TD_EXT_GUI_S] = ACTION_TAP_DANCE_FN_ADVANCED(NULL, on_tap_dance_ext_gui_s_finished, on_tap_dance_ext_gui_s_reset),
    // Further actions
};
```

Now repeat this process for 'd' with `LGUI(KC_D)` replaced by `KC_D` for a single tap and 'hold' with `KC_LCTRL`. Do the same for 'f' with `LGUI(KC_F)` and `KC_LSFT`.

With these dedicated tap dance functions, you can directly manipulate each key's behavior and reset independently. Ensure these functions are correctly hooked up in the `tap_dance_actions` array, corresponding to their tap dance codes.

This approach has separated the tap and hold behaviors for each individual key, eliminating the potential complications of a shared generic function. Adjust and test these functions individually until you get the expected behavior. If additional issues arise, you may need to check for conflicting code or hardware problems.

Once your tap and hold actions work as expected, remember to verify the behavior across different software and consider whether other layers or configurations could interfere with your tap dance definitions.

🗨:

is this even correct?

```c
uint8_t dance_step(tap_dance_state_t *state) {
    if (state->count == 1) {
        if (state->interrupted || !state->pressed)
            return SINGLE_TAP;
        else
            return SINGLE_HOLD;
    } else if (state->count == 2) {
        if (state->interrupted && state->pressed)
            return TAP_HOLD;
        else if (!state->interrupted && state->pressed)
            return DOUBLE_HOLD;
        else
            return DOUBLE_TAP;
    }
    return MORE_TAPS;
}
```

🤖:[ChatGPT4]
Yes, the `dance_step` function you provided follows the intention of the tap dance feature within QMK correctly based on the typical uses. This function assesses the state of the tap dance event and returns an enumerated value corresponding to the type of action detected (single tap, single hold, double tap, etc.).

However, whether it is 'correct' also depends on how you are utilising it within your broader keymap and functions. If your implementation solely relies on differentiating between single-tap and single-hold actions (and not double taps or holds), then you can simplify this by not considering double tap events:

Here’s a simplified version that only cares about single tap or hold:

```c
uint8_t dance_step(tap_dance_state_t *state) {
    if (state->count == 1) {
        if (!state->pressed) { // Released: single tap
            return SINGLE_TAP;
        } else { // Still held down: single hold
            return SINGLE_HOLD;
        }
    }
    return MORE_TAPS; // For additional tap counts, return MORE_TAPS or handle as needed
}
```

The important distinction for the logic you want is effectively whether the key was _released_ after the first tap, which would count as a `SINGLE_TAP`, or if it is being _held_ during the time the function checks, which is a `SINGLE_HOLD`. The variables `state->interrupted` and `state->pressed` play a crucial role. You must correctly assess them within this function, as they directly influence the return action:

- `state->interrupted`: This is set to true if the tap dance was interrupted by another key press.
- `state->pressed`: This is true if the key is still being pressed when the function is called.

Note that a `DOUBLE_TAP` could also be interpreted differently if you want some form of distinction when quickly tapping a key twice, which is something you might not have implemented yet. It's not required unless you want some specific behavior for that case. If you're handling `SINGLE_TAP` and `SINGLE_HOLD` exclusively, you might not need the complexity of the other cases.

Assuming you are not using these, they could be omitted for simplicity, as reflected in the provided function. If there are specific behaviors you want to implement for double taps or holds, these would need to be added both in your detection (in `dance_step`) and in your handling/reset functions.

🗨:
Okay i have this, but i not tried it yet:

```c
uint8_t dance_step(tap_dance_state_t *state) {
    if (state->count == 1) {
        if (!state->pressed) { // Released: single tap
            return SINGLE_TAP;
        } else { // Still held down: single hold
            return SINGLE_HOLD;
        }
    } else if (state->count == 2) {
        if (!state->pressed) { // Released: double tap
            return DOUBLE_TAP;
        } else { // Still held down: double hold
            return DOUBLE_HOLD;
        }
    } else {
        if (!state->pressed) { // Released: tap hold
            return MORE_TAPS;  // For additional tap counts, return MORE_TAPS or handle as needed
        }
    }
}


void on_TD_EXT_GUI_A(tap_dance_state_t *state, void *user_data) {
    state = dance_step(state);

    switch (state) {
        case SINGLE_TAP:
            // Single Tap: GUI + Key A
            register_code(KC_LGUI);
            register_code(KC_A);
            unregister_code(KC_A);
            unregister_code(KC_LGUI);
            break;
        case SINGLE_HOLD:
            // Hold: Just GUI
            register_code(KC_LGUI);
            break;
    }
}

void TD_EXT_GUI_A_reset(tap_dance_state_t *state, void *user_data) {
    unregister_code(KC_LGUI);
}
```

🤖:[ChatGPT4]
The `dance_step` function and the `on_TD_EXT_GUI_A` and `TD_EXT_GUI_A_reset` functions appear to be based on valid logic for using tap dance keys in QMK.

There's a semantic error in using `state` within `on_TD_EXT_GUI_A` function. `state` is a pointer to `tap_dance_state_t`, but you have used `state = dance_step(state);`, which assigns an `uint8_t` to a pointer of `tap_dance_state_t`. Instead, you need to call `dance_step` and use its return value as the case condition.

Here's how `on_TD_EXT_GUI_A` should be corrected:

```c
void on_TD_EXT_GUI_A(tap_dance_state_t *state, void *user_data) {
    uint8_t result = dance_step(state);

    switch (result) {
        case SINGLE_TAP:
            // Single Tap: GUI + Key A
            register_code(KC_LGUI);
            register_code(KC_A);
            unregister_code(KC_A);
            unregister_code(KC_LGUI);
            break;
        case SINGLE_HOLD:
            // Hold: Just GUI
            register_code(KC_LGUI);
            break;
        // Add case DOUBLE_TAP and Double Hold if needed
    }
}
```

For `TD_EXT_GUI_A_reset` function, it is fine as it is because it only needs to unregister the command key.

```c
void TD_EXT_GUI_A_reset(tap_dance_state_t *state, void *user_data) {
    unregister_code(KC_LGUI);
}
```

Don’t forget to correctly register your tap dance actions within `tap_dance_actions` array:

```c
qk_tap_dance_action_t tap_dance_actions[] = {
    [TD_EXT_GUI_A] = ACTION_TAP_DANCE_FN_ADVANCED(NULL, on_TD_EXT_GUI_A, TD_EXT_GUI_A_reset),
    //... other tap dance actions
};
```

Before you test it, please ensure you do not have any unused or conflicting actions in `tap_dance_actions` or `dance_step`. If you’re not using double-tap and double-hold, you can remove those cases from `dance_step`. Always test one step at a time to make sure each individual key’s tap and hold functionality is working correctly. If everything looks good, connect your keyboard and see how it behaves.

🗨:
I get this error:

❯ qmk compile
Ψ Compiling keymap with gmake -r -R -f builddefs/build_keyboard.mk -s KEYBOARD=crkbd/rev1 KEYMAP=koyo KEYBOARD_FILESAFE=crkbd_rev1 TARGET=crkbd_rev1_koyo INTERMEDIATE_OUTPUT=.build/obj_crkbd_rev1_koyo VERBOSE=false COLOR=true SILENT=false QMK_BIN="qmk"

avr-gcc (Homebrew AVR GCC 8.5.0_2) 8.5.0
Copyright (C) 2018 Free Software Foundation, Inc.
This is free software; see the source for copying conditions. There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

Size before:
text data bss dec hex filename
0 27034 0 27034 699a crkbd_rev1_koyo.hex

Compiling: quantum/keymap_introspection.c In file included from quantum/keymap_introspection.c:5:
./keyboards/crkbd/keymaps/koyo/keymap.c: In function 'dance_step':
./keyboards/crkbd/keymaps/koyo/keymap.c:199:1: error: control reaches end of non-void function [-Werror=return-type]
}
^
cc1: all warnings being treated as errors
[ERRORS]
|
|
|
gmake: \*\*\* [builddefs/common_rules.mk:373: .build/obj_crkbd_rev1_koyo/quantum/keymap_introspection.o] Error 1

this is what i have:

```
/*
Copyright 2019 @foostan
Copyright 2020 Drashna Jaelre <@drashna>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include QMK_KEYBOARD_H

enum layers {
    //
    LY_BAS,
    LY_EXT,
    LY_SYM,
    LY_NUM,
    LY_FUN,
    LY_MED
};

enum custom_keycodes {
    SS_TILD_SLSH = SAFE_RANGE,
};

enum tap_dance_codes {
    //
    TD_EXT_GUI_A,
    TD_EXT_GUI_S,
    TD_EXT_GUI_D,
    TD_EXT_GUI_F
};

// KEYMAP ===============================================================================
// clang-format off
const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = {
[LY_BAS] = LAYOUT_split_3x5_3(
//    ┌───────────┬───────────┬────────────────┬─────────────────┬─────────────────┐   ┌──────────────────┬─────────────────┬────────────────┬───────────┬───────────┐
//    │     q     │     w     │       e        │        r        │        t        │   │        y         │        u        │       i        │     o     │     p     │
//    ├───────────┼───────────┼────────────────┼─────────────────┼─────────────────┤   ├──────────────────┼─────────────────┼────────────────┼───────────┼───────────┤
//    │     a     │     s     │       d        │        f        │        g        │   │        h         │        j        │       k        │     l     │     ;     │
//    ├───────────┼───────────┼────────────────┼─────────────────┼─────────────────┤   ├──────────────────┼─────────────────┼────────────────┼───────────┼───────────┤
//    │ LGUI_T(z) │ LALT_T(x) │   LCTL_T(c)    │    LSFT_T(v)    │        b        │   │        n         │    RSFT_T(m)    │   RCTL_T(,)    │ LALT_T(.) │ RGUI_T(/) │
//    └───────────┴───────────┼────────────────┼─────────────────┼─────────────────┤   ├──────────────────┼─────────────────┼────────────────┼───────────┴───────────┘
//                            │ LT(LY_NUM, no) │ LT(LY_SYM, esc) │ LT(LY_EXT, spc) │   │ LT(LY_MED, bspc) │ LT(LY_SYM, ent) │ LT(LY_FUN, no) │
//                            └────────────────┴─────────────────┴─────────────────┘   └──────────────────┴─────────────────┴────────────────┘
  KC_Q         , KC_W         , KC_E              , KC_R               , KC_T               ,     KC_Y                , KC_U               , KC_I              , KC_O           , KC_P           ,
  KC_A         , KC_S         , KC_D              , KC_F               , KC_G               ,     KC_H                , KC_J               , KC_K              , KC_L           , KC_SCLN        ,
  LGUI_T(KC_Z) , LALT_T(KC_X) , LCTL_T(KC_C)      , LSFT_T(KC_V)       , KC_B               ,     KC_N                , RSFT_T(KC_M)       , RCTL_T(KC_COMM)   , LALT_T(KC_DOT) , RGUI_T(KC_SLSH),
                                LT(LY_NUM, KC_NO) , LT(LY_SYM, KC_ESC) , LT(LY_EXT, KC_SPC) ,     LT(LY_MED, KC_BSPC) , LT(LY_SYM, KC_ENT) , LT(LY_FUN, KC_NO)
),

[LY_EXT] = LAYOUT_split_3x5_3(
//    ┌──────────────────┬──────────────────┬──────────────────┬──────────────────┬────────────┐   ┌──────┬────────┬───────────┬───────────┬────┐
//    │     LGUI(q)      │     LGUI(w)      │     LGUI(e)      │     LGUI(r)      │  LGUI(t)   │   │  no  │ LAG(i) │  LGUI(`)  │ LGUI(tab) │ no │
//    ├──────────────────┼──────────────────┼──────────────────┼──────────────────┼────────────┤   ├──────┼────────┼───────────┼───────────┼────┤
//    │ TD(TD_EXT_GUI_A) │ TD(TD_EXT_GUI_S) │ TD(TD_EXT_GUI_D) │ TD(TD_EXT_GUI_F) │  LGUI(g)   │   │ left │  down  │    up     │   rght    │ no │
//    ├──────────────────┼──────────────────┼──────────────────┼──────────────────┼────────────┤   ├──────┼────────┼───────────┼───────────┼────┤
//    │     LGUI(z)      │     LGUI(x)      │     LGUI(c)      │     LGUI(v)      │  LGUI(b)   │   │  no  │   no   │ LSFT(tab) │    tab    │ no │
//    └──────────────────┴──────────────────┼──────────────────┼──────────────────┼────────────┤   ├──────┼────────┼───────────┼───────────┴────┘
//                                          │        no        │        no        │ TO(LY_BAS) │   │ del  │   no   │    no     │
//                                          └──────────────────┴──────────────────┴────────────┘   └──────┴────────┴───────────┘
  LGUI(KC_Q)       , LGUI(KC_W)       , LGUI(KC_E)       , LGUI(KC_R)       , LGUI(KC_T) ,     KC_NO   , LAG(KC_I) , LGUI(KC_GRV) , LGUI(KC_TAB) , KC_NO,
  TD(TD_EXT_GUI_A) , TD(TD_EXT_GUI_S) , TD(TD_EXT_GUI_D) , TD(TD_EXT_GUI_F) , LGUI(KC_G) ,     KC_LEFT , KC_DOWN   , KC_UP        , KC_RGHT      , KC_NO,
  LGUI(KC_Z)       , LGUI(KC_X)       , LGUI(KC_C)       , LGUI(KC_V)       , LGUI(KC_B) ,     KC_NO   , KC_NO     , LSFT(KC_TAB) , KC_TAB       , KC_NO,
                                        KC_NO            , KC_NO            , TO(LY_BAS) ,     KC_DEL  , KC_NO     , KC_NO
),

[LY_SYM] = LAYOUT_split_3x5_3(
//    ┌───┬───┬─────┬────────────┬─────┐   ┌─────┬────────────┬─────┬───┬───┐
//    │ ^ │ + │  #  │     %      │  $  │   │  <  │     {      │  "  │ } │ > │
//    ├───┼───┼─────┼────────────┼─────┤   ├─────┼────────────┼─────┼───┼───┤
//    │ ! │ - │  &  │     ?      │  |  │   │  =  │     [      │  '  │ ] │ : │
//    ├───┼───┼─────┼────────────┼─────┤   ├─────┼────────────┼─────┼───┼───┤
//    │ ~ │ _ │  *  │     @      │ ~/  │   │  \  │     (      │  `  │ ) │ / │
//    └───┴───┼─────┼────────────┼─────┤   ├─────┼────────────┼─────┼───┴───┘
//            │     │ TO(LY_BAS) │     │   │     │ TO(LY_BAS) │     │
//            └─────┴────────────┴─────┘   └─────┴────────────┴─────┘
  KC_CIRC , KC_PLUS , KC_HASH , KC_PERC    , KC_DLR       ,     KC_LT   , KC_LCBR    , KC_DQUO , KC_RCBR , KC_GT  ,
  KC_EXLM , KC_MINS , KC_AMPR , KC_QUES    , KC_PIPE      ,     KC_EQL  , KC_LBRC    , KC_QUOT , KC_RBRC , KC_COLN,
  KC_TILD , KC_UNDS , KC_ASTR , KC_AT      , SS_TILD_SLSH ,     KC_BSLS , KC_LPRN    , KC_GRV  , KC_RPRN , KC_SLSH,
                      KC_TRNS , TO(LY_BAS) , KC_TRNS      ,     KC_TRNS , TO(LY_BAS) , KC_TRNS
),

[LY_NUM] = LAYOUT_split_3x5_3(
//    ┌──────────┬─────────┬──────┬──────┬─────┐   ┌──────┬──────┬──────┬──────┬──────┐
//    │ HYPR(no) │ MEH(no) │  no  │  no  │ no  │   │ kp_+ │ kp_7 │ kp_8 │ kp_9 │ kp_* │
//    ├──────────┼─────────┼──────┼──────┼─────┤   ├──────┼──────┼──────┼──────┼──────┤
//    │   lgui   │  lalt   │ lctl │ lsft │ no  │   │ kp_= │ kp_4 │ kp_5 │ kp_6 │  :   │
//    ├──────────┼─────────┼──────┼──────┼─────┤   ├──────┼──────┼──────┼──────┼──────┤
//    │    no    │   no    │  no  │  no  │ no  │   │ kp_- │ kp_1 │ kp_2 │ kp_3 │ kp_/ │
//    └──────────┴─────────┼──────┼──────┼─────┤   ├──────┼──────┼──────┼──────┴──────┘
//                         │      │      │     │   │      │ kp_0 │      │
//                         └──────┴──────┴─────┘   └──────┴──────┴──────┘
  HYPR(KC_NO) , MEH(KC_NO) , KC_NO   , KC_NO   , KC_NO   ,     KC_PPLS , KC_P7 , KC_P8   , KC_P9 , KC_PAST,
  KC_LGUI     , KC_LALT    , KC_LCTL , KC_LSFT , KC_NO   ,     KC_PEQL , KC_P4 , KC_P5   , KC_P6 , KC_COLN,
  KC_NO       , KC_NO      , KC_NO   , KC_NO   , KC_NO   ,     KC_PMNS , KC_P1 , KC_P2   , KC_P3 , KC_PSLS,
                             KC_TRNS , KC_TRNS , KC_TRNS ,     KC_TRNS , KC_P0 , KC_TRNS
),

[LY_FUN] = LAYOUT_split_3x5_3(
//    ┌────┬────┬────┬────┬─────┐   ┌────┬──────┬──────┬─────────┬──────────┐
//    │ no │ f7 │ f8 │ f9 │ f12 │   │ no │  no  │  no  │ MEH(no) │ HYPR(no) │
//    ├────┼────┼────┼────┼─────┤   ├────┼──────┼──────┼─────────┼──────────┤
//    │ no │ f4 │ f5 │ f6 │ f11 │   │ no │ rsft │ rctl │  lalt   │   rgui   │
//    ├────┼────┼────┼────┼─────┤   ├────┼──────┼──────┼─────────┼──────────┤
//    │ no │ f1 │ f2 │ f3 │ f10 │   │ no │  no  │  no  │   no    │    no    │
//    └────┴────┼────┼────┼─────┤   ├────┼──────┼──────┼─────────┴──────────┘
//              │ no │ no │ no  │   │ no │  no  │  no  │
//              └────┴────┴─────┘   └────┴──────┴──────┘
  KC_NO , KC_F7 , KC_F8 , KC_F9 , KC_F12 ,     KC_NO , KC_NO   , KC_NO   , MEH(KC_NO) , HYPR(KC_NO),
  KC_NO , KC_F4 , KC_F5 , KC_F6 , KC_F11 ,     KC_NO , KC_RSFT , KC_RCTL , KC_LALT    , KC_RGUI    ,
  KC_NO , KC_F1 , KC_F2 , KC_F3 , KC_F10 ,     KC_NO , KC_NO   , KC_NO   , KC_NO      , KC_NO      ,
                  KC_NO , KC_NO , KC_NO  ,     KC_NO , KC_NO   , KC_NO
),

[LY_MED] = LAYOUT_split_3x5_3(
//    ┌────┬──────┬──────┬──────┬────────┐   ┌────┬─────────┬─────────┬─────────┬────┐
//    │ no │ vold │ mute │ volu │   no   │   │ no │ RGB_HUD │ RGB_TOG │ RGB_HUI │ no │
//    ├────┼──────┼──────┼──────┼────────┤   ├────┼─────────┼─────────┼─────────┼────┤
//    │ no │ mprv │ mply │ mnxt │ MEH(k) │   │ no │ LGUI(-) │ LGUI(0) │ LGUI(=) │ no │
//    ├────┼──────┼──────┼──────┼────────┤   ├────┼─────────┼─────────┼─────────┼────┤
//    │ no │  no  │  no  │  no  │   no   │   │ no │ DT_DOWN │ DT_PRNT │  DT_UP  │ no │
//    └────┴──────┼──────┼──────┼────────┤   ├────┼─────────┼─────────┼─────────┴────┘
//                │  no  │  no  │   no   │   │ no │   no    │   no    │
//                └──────┴──────┴────────┘   └────┴─────────┴─────────┘
  KC_NO , KC_VOLD , KC_MUTE , KC_VOLU , KC_NO     ,     KC_NO , RGB_HUD       , RGB_TOG    , RGB_HUI      , KC_NO,
  KC_NO , KC_MPRV , KC_MPLY , KC_MNXT , MEH(KC_K) ,     KC_NO , LGUI(KC_MINS) , LGUI(KC_0) , LGUI(KC_EQL) , KC_NO,
  KC_NO , KC_NO   , KC_NO   , KC_NO   , KC_NO     ,     KC_NO , DT_DOWN       , DT_PRNT    , DT_UP        , KC_NO,
                    KC_NO   , KC_NO   , KC_NO     ,     KC_NO , KC_NO         , KC_NO
)
};
// clang-format on

// COMBO ================================================================================
const uint16_t PROGMEM togg_layer_ext_combo[] = {LT(LY_EXT, KC_SPC), LT(LY_MED, KC_BSPC), COMBO_END};
const uint16_t PROGMEM togg_layer_sym_combo[] = {LT(LY_SYM, KC_ESC), LT(LY_SYM, KC_ENT), COMBO_END};
const uint16_t PROGMEM togg_caps_word_combo[] = {LSFT_T(KC_V), RSFT_T(KC_M), COMBO_END};

combo_t key_combos[] = {
    COMBO(togg_layer_ext_combo, TO(LY_EXT)),
    COMBO(togg_layer_sym_combo, TO(LY_SYM)),
    COMBO(togg_caps_word_combo, CW_TOGG),
};

// SEND STRING ==========================================================================
bool process_record_user(uint16_t keycode, keyrecord_t *record) {
    switch (keycode) {
        case SS_TILD_SLSH:
            if (record->event.pressed) {
                SEND_STRING("~/");
            } else {
                // when keycode is released
            }
            break;
    }

    return true;
}

// TAP DANCE ============================================================================
enum tab_dance_events {
    //
    SINGLE_TAP = 1,
    SINGLE_HOLD,
    DOUBLE_TAP,
    DOUBLE_HOLD,
    TAP_HOLD,
    MORE_TAPS
};

uint8_t dance_step(tap_dance_state_t *state) {
    if (state->count == 1) {
        if (!state->pressed) { // Released: single tap
            return SINGLE_TAP;
        } else { // Still held down: single hold
            return SINGLE_HOLD;
        }
    } else if (state->count == 2) {
        if (!state->pressed) { // Released: double tap
            return DOUBLE_TAP;
        } else { // Still held down: double hold
            return DOUBLE_HOLD;
        }
    } else {
        if (!state->pressed) { // Released: tap hold
            return MORE_TAPS;  // For additional tap counts, return MORE_TAPS or handle as needed
        }
    }
}

void custom_handle_tap_dance(tap_dance_state_t *state, uint16_t tap_single, uint16_t hold) {
    switch (dance_step(state)) {
        case SINGLE_TAP:
            register_code16(tap_single);
            break;
        case SINGLE_HOLD:
            register_code16(hold);
            break;
        case DOUBLE_TAP:
            register_code16(tap_single);
            register_code16(tap_single);
            break;
        default:
            break;
    }
}

void custom_reset_tap_dance(tap_dance_state_t *state, uint16_t tap_single, uint16_t hold) {
    switch (dance_step(state)) {
        case SINGLE_TAP:
            unregister_code16(tap_single);
            break;
        case SINGLE_HOLD:
            unregister_code16(hold);
            clear_mods(); // Clear all mods to be safe.
            break;
        case DOUBLE_TAP:
            unregister_code16(tap_single);
            break;
        case DOUBLE_HOLD:
            unregister_code16(hold);
            clear_mods(); // Clear all mods to be safe.
            break;
        default:
            unregister_code16(tap_single);
            unregister_code16(hold);
            break;
    }
}

void on_TD_EXT_GUI_A(tap_dance_state_t *state, void *user_data) {
    uint8_t dance = dance_step(state);

    switch (dance) {
        case SINGLE_TAP:
            // Single Tap: GUI + Key A
            register_code(KC_LGUI);
            register_code(KC_A);
            unregister_code(KC_A);
            unregister_code(KC_LGUI);
            break;
        case SINGLE_HOLD:
            // Hold: Just GUI
            register_code(KC_LGUI);
            break;
    }
}

void TD_EXT_GUI_A_reset(tap_dance_state_t *state, void *user_data) {
    unregister_code(KC_LGUI);
}

void on_TD_EXT_GUI_S(tap_dance_state_t *state, void *user_data) {
    custom_handle_tap_dance(state, LGUI(KC_S), KC_LEFT_ALT);
}

void TD_EXT_GUI_S_reset(tap_dance_state_t *state, void *user_data) {
    custom_reset_tap_dance(state, LGUI(KC_S), KC_LEFT_ALT);
}

void on_TD_EXT_GUI_D(tap_dance_state_t *state, void *user_data) {
    custom_handle_tap_dance(state, LGUI(KC_D), KC_LEFT_CTRL);
}

void TD_EXT_GUI_D_reset(tap_dance_state_t *state, void *user_data) {
    custom_reset_tap_dance(state, LGUI(KC_D), KC_LEFT_CTRL);
}

void on_TD_EXT_GUI_F(tap_dance_state_t *state, void *user_data) {
    custom_handle_tap_dance(state, LGUI(KC_F), KC_LEFT_SHIFT);
}

void TD_EXT_GUI_F_reset(tap_dance_state_t *state, void *user_data) {
    custom_reset_tap_dance(state, LGUI(KC_F), KC_LEFT_SHIFT);
}

// clang-format off
tap_dance_action_t tap_dance_actions[] = {
    [TD_EXT_GUI_A] = ACTION_TAP_DANCE_FN_ADVANCED(NULL, on_TD_EXT_GUI_A, TD_EXT_GUI_A_reset),
    [TD_EXT_GUI_S] = ACTION_TAP_DANCE_FN_ADVANCED(NULL, on_TD_EXT_GUI_S, TD_EXT_GUI_S_reset),
    [TD_EXT_GUI_D] = ACTION_TAP_DANCE_FN_ADVANCED(NULL, on_TD_EXT_GUI_D, TD_EXT_GUI_D_reset),
    [TD_EXT_GUI_F] = ACTION_TAP_DANCE_FN_ADVANCED(NULL, on_TD_EXT_GUI_F, TD_EXT_GUI_F_reset),
};
```

🤖:[ChatGPT4]
Looking at the error message from the compiler:

```
error: control reaches end of non-void function [-Werror=return-type]
```

This indicates that not all paths in the `dance_step` function result in a value being returned. This function must always return a value since it’s declared to return an `uint8_t`. The last `else` block lacks a return statement which is probably causing the error. 

Here’s the corrected `dance_step` function:

```c
uint8_t dance_step(tap_dance_state_t *state) {
    if (state->count == 1) {
        if (!state->pressed) { // Released: single tap
            return SINGLE_TAP;
        } else { // Still held down: single hold
            return SINGLE_HOLD;
        }
    } else if (state->count == 2) {
        if (!state->pressed) { // Released: double tap
            return DOUBLE_TAP;
        } else { // Still held down: double hold
            return DOUBLE_HOLD;
        }
    }
    // Return 'MORE_TAPS' or another default case for when count is more than 2.
    return MORE_TAPS;
}
```

Additionally, in your `on_TD_EXT_GUI_A` function, the variable shouldn't be renamed from `state` to `dance`, as comes from the function itself and should stay as is. And you should call `dance_step(state)` properly. Here's the corrected implementation:

```c
void on_TD_EXT_GUI_A(qk_tap_dance_state_t *state, void *user_data) {
    uint8_t dance = dance_step(state);

    switch (dance) {
        case SINGLE_TAP:
            // Single Tap: GUI + Key A
            register_code(KC_LGUI);
            register_code(KC_A);
            unregister_code(KC_A);
            unregister_code(KC_LGUI);
            break;
        case SINGLE_HOLD:
            // Hold: Just GUI
            register_code(KC_LGUI);
            break;
    }
}
```

Please make the modifications above, and try to compile again. If you face further compilation issues, ensure that each function and its control paths are valid, returning the correct type of values expected.


🗨:

